package pb

import (
	context "context"
	fmt "fmt"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	gorm "gorm.io/gorm"
)

type SequenceORM struct {
	Class  string
	Id     string `gorm:"type:uuid;primaryKey"`
	Values string
}

// TableName overrides the default tablename generated by GORM
func (SequenceORM) TableName() string {
	return "sequences"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Sequence) ToORM(ctx context.Context) (SequenceORM, error) {
	to := SequenceORM{}
	var err error
	if prehook, ok := interface{}(m).(SequenceWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Class = m.Class
	to.Values = m.Values
	if posthook, ok := interface{}(m).(SequenceWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *SequenceORM) ToPB(ctx context.Context) (Sequence, error) {
	to := Sequence{}
	var err error
	if prehook, ok := interface{}(m).(SequenceWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Class = m.Class
	to.Values = m.Values
	if posthook, ok := interface{}(m).(SequenceWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Sequence the arg will be the target, the caller the one being converted from

// SequenceBeforeToORM called before default ToORM code
type SequenceWithBeforeToORM interface {
	BeforeToORM(context.Context, *SequenceORM) error
}

// SequenceAfterToORM called after default ToORM code
type SequenceWithAfterToORM interface {
	AfterToORM(context.Context, *SequenceORM) error
}

// SequenceBeforeToPB called before default ToPB code
type SequenceWithBeforeToPB interface {
	BeforeToPB(context.Context, *Sequence) error
}

// SequenceAfterToPB called after default ToPB code
type SequenceWithAfterToPB interface {
	AfterToPB(context.Context, *Sequence) error
}

type TCPSequenceORM struct {
	Difficulty string
	Id         string `gorm:"type:uuid;primaryKey"`
	Index      int32
	Values     string
}

// TableName overrides the default tablename generated by GORM
func (TCPSequenceORM) TableName() string {
	return "tcp_sequences"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *TCPSequence) ToORM(ctx context.Context) (TCPSequenceORM, error) {
	to := TCPSequenceORM{}
	var err error
	if prehook, ok := interface{}(m).(TCPSequenceWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Index = m.Index
	to.Difficulty = m.Difficulty
	to.Values = m.Values
	if posthook, ok := interface{}(m).(TCPSequenceWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TCPSequenceORM) ToPB(ctx context.Context) (TCPSequence, error) {
	to := TCPSequence{}
	var err error
	if prehook, ok := interface{}(m).(TCPSequenceWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Index = m.Index
	to.Difficulty = m.Difficulty
	to.Values = m.Values
	if posthook, ok := interface{}(m).(TCPSequenceWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type TCPSequence the arg will be the target, the caller the one being converted from

// TCPSequenceBeforeToORM called before default ToORM code
type TCPSequenceWithBeforeToORM interface {
	BeforeToORM(context.Context, *TCPSequenceORM) error
}

// TCPSequenceAfterToORM called after default ToORM code
type TCPSequenceWithAfterToORM interface {
	AfterToORM(context.Context, *TCPSequenceORM) error
}

// TCPSequenceBeforeToPB called before default ToPB code
type TCPSequenceWithBeforeToPB interface {
	BeforeToPB(context.Context, *TCPSequence) error
}

// TCPSequenceAfterToPB called after default ToPB code
type TCPSequenceWithAfterToPB interface {
	AfterToPB(context.Context, *TCPSequence) error
}

type IPIDSequenceORM struct {
	Difficulty string
	Id         string `gorm:"type:uuid;primaryKey"`
	Index      int32
	Values     string
}

// TableName overrides the default tablename generated by GORM
func (IPIDSequenceORM) TableName() string {
	return "ip_id_sequences"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *IPIDSequence) ToORM(ctx context.Context) (IPIDSequenceORM, error) {
	to := IPIDSequenceORM{}
	var err error
	if prehook, ok := interface{}(m).(IPIDSequenceWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Index = m.Index
	to.Difficulty = m.Difficulty
	to.Values = m.Values
	if posthook, ok := interface{}(m).(IPIDSequenceWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *IPIDSequenceORM) ToPB(ctx context.Context) (IPIDSequence, error) {
	to := IPIDSequence{}
	var err error
	if prehook, ok := interface{}(m).(IPIDSequenceWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Index = m.Index
	to.Difficulty = m.Difficulty
	to.Values = m.Values
	if posthook, ok := interface{}(m).(IPIDSequenceWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type IPIDSequence the arg will be the target, the caller the one being converted from

// IPIDSequenceBeforeToORM called before default ToORM code
type IPIDSequenceWithBeforeToORM interface {
	BeforeToORM(context.Context, *IPIDSequenceORM) error
}

// IPIDSequenceAfterToORM called after default ToORM code
type IPIDSequenceWithAfterToORM interface {
	AfterToORM(context.Context, *IPIDSequenceORM) error
}

// IPIDSequenceBeforeToPB called before default ToPB code
type IPIDSequenceWithBeforeToPB interface {
	BeforeToPB(context.Context, *IPIDSequence) error
}

// IPIDSequenceAfterToPB called after default ToPB code
type IPIDSequenceWithAfterToPB interface {
	AfterToPB(context.Context, *IPIDSequence) error
}

type TCPTSSequenceORM struct {
	Difficulty string
	Id         string `gorm:"type:uuid;primaryKey"`
	Index      int32
	Values     string
}

// TableName overrides the default tablename generated by GORM
func (TCPTSSequenceORM) TableName() string {
	return "tcpts_sequences"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *TCPTSSequence) ToORM(ctx context.Context) (TCPTSSequenceORM, error) {
	to := TCPTSSequenceORM{}
	var err error
	if prehook, ok := interface{}(m).(TCPTSSequenceWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Index = m.Index
	to.Difficulty = m.Difficulty
	to.Values = m.Values
	if posthook, ok := interface{}(m).(TCPTSSequenceWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TCPTSSequenceORM) ToPB(ctx context.Context) (TCPTSSequence, error) {
	to := TCPTSSequence{}
	var err error
	if prehook, ok := interface{}(m).(TCPTSSequenceWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Index = m.Index
	to.Difficulty = m.Difficulty
	to.Values = m.Values
	if posthook, ok := interface{}(m).(TCPTSSequenceWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type TCPTSSequence the arg will be the target, the caller the one being converted from

// TCPTSSequenceBeforeToORM called before default ToORM code
type TCPTSSequenceWithBeforeToORM interface {
	BeforeToORM(context.Context, *TCPTSSequenceORM) error
}

// TCPTSSequenceAfterToORM called after default ToORM code
type TCPTSSequenceWithAfterToORM interface {
	AfterToORM(context.Context, *TCPTSSequenceORM) error
}

// TCPTSSequenceBeforeToPB called before default ToPB code
type TCPTSSequenceWithBeforeToPB interface {
	BeforeToPB(context.Context, *TCPTSSequence) error
}

// TCPTSSequenceAfterToPB called after default ToPB code
type TCPTSSequenceWithAfterToPB interface {
	AfterToPB(context.Context, *TCPTSSequence) error
}

type ICMPResponseORM struct {
	Code uint32
	Id   string `gorm:"type:uuid;primaryKey"`
	Type int32
}

// TableName overrides the default tablename generated by GORM
func (ICMPResponseORM) TableName() string {
	return "icmp_responses"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ICMPResponse) ToORM(ctx context.Context) (ICMPResponseORM, error) {
	to := ICMPResponseORM{}
	var err error
	if prehook, ok := interface{}(m).(ICMPResponseWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Type = int32(m.Type)
	to.Code = m.Code
	if posthook, ok := interface{}(m).(ICMPResponseWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ICMPResponseORM) ToPB(ctx context.Context) (ICMPResponse, error) {
	to := ICMPResponse{}
	var err error
	if prehook, ok := interface{}(m).(ICMPResponseWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Type = ICMPType(m.Type)
	to.Code = m.Code
	if posthook, ok := interface{}(m).(ICMPResponseWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ICMPResponse the arg will be the target, the caller the one being converted from

// ICMPResponseBeforeToORM called before default ToORM code
type ICMPResponseWithBeforeToORM interface {
	BeforeToORM(context.Context, *ICMPResponseORM) error
}

// ICMPResponseAfterToORM called after default ToORM code
type ICMPResponseWithAfterToORM interface {
	AfterToORM(context.Context, *ICMPResponseORM) error
}

// ICMPResponseBeforeToPB called before default ToPB code
type ICMPResponseWithBeforeToPB interface {
	BeforeToPB(context.Context, *ICMPResponse) error
}

// ICMPResponseAfterToPB called after default ToPB code
type ICMPResponseWithAfterToPB interface {
	AfterToPB(context.Context, *ICMPResponse) error
}

// DefaultCreateSequence executes a basic gorm create call
func DefaultCreateSequence(ctx context.Context, in *Sequence, db *gorm.DB) (*Sequence, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SequenceORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SequenceORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type SequenceORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SequenceORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadSequence(ctx context.Context, in *Sequence, db *gorm.DB) (*Sequence, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SequenceORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(SequenceORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := SequenceORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(SequenceORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type SequenceORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SequenceORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SequenceORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteSequence(ctx context.Context, in *Sequence, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SequenceORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&SequenceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(SequenceORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type SequenceORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SequenceORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteSequenceSet(ctx context.Context, in []*Sequence, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&SequenceORM{})).(SequenceORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&SequenceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&SequenceORM{})).(SequenceORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type SequenceORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Sequence, *gorm.DB) (*gorm.DB, error)
}
type SequenceORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Sequence, *gorm.DB) error
}

// DefaultStrictUpdateSequence clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateSequence(ctx context.Context, in *Sequence, db *gorm.DB) (*Sequence, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateSequence")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &SequenceORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(SequenceORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(SequenceORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SequenceORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type SequenceORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SequenceORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SequenceORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchSequence executes a basic gorm update call with patch behavior
func DefaultPatchSequence(ctx context.Context, in *Sequence, updateMask *field_mask.FieldMask, db *gorm.DB) (*Sequence, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Sequence
	var err error
	if hook, ok := interface{}(&pbObj).(SequenceWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadSequence(ctx, &Sequence{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(SequenceWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskSequence(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(SequenceWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateSequence(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(SequenceWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type SequenceWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Sequence, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SequenceWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Sequence, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SequenceWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Sequence, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SequenceWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Sequence, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetSequence executes a bulk gorm update call with patch behavior
func DefaultPatchSetSequence(ctx context.Context, objects []*Sequence, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Sequence, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Sequence, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchSequence(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskSequence patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskSequence(ctx context.Context, patchee *Sequence, patcher *Sequence, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Sequence, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Class" {
			patchee.Class = patcher.Class
			continue
		}
		if f == prefix+"Values" {
			patchee.Values = patcher.Values
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListSequence executes a gorm list call
func DefaultListSequence(ctx context.Context, db *gorm.DB) ([]*Sequence, error) {
	in := Sequence{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SequenceORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(SequenceORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []SequenceORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SequenceORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Sequence{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type SequenceORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SequenceORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SequenceORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]SequenceORM) error
}

// DefaultCreateTCPSequence executes a basic gorm create call
func DefaultCreateTCPSequence(ctx context.Context, in *TCPSequence, db *gorm.DB) (*TCPSequence, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TCPSequenceORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TCPSequenceORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TCPSequenceORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TCPSequenceORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadTCPSequence(ctx context.Context, in *TCPSequence, db *gorm.DB) (*TCPSequence, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TCPSequenceORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TCPSequenceORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TCPSequenceORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TCPSequenceORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TCPSequenceORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TCPSequenceORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TCPSequenceORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteTCPSequence(ctx context.Context, in *TCPSequence, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TCPSequenceORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TCPSequenceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TCPSequenceORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TCPSequenceORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TCPSequenceORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteTCPSequenceSet(ctx context.Context, in []*TCPSequence, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TCPSequenceORM{})).(TCPSequenceORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TCPSequenceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TCPSequenceORM{})).(TCPSequenceORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TCPSequenceORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*TCPSequence, *gorm.DB) (*gorm.DB, error)
}
type TCPSequenceORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*TCPSequence, *gorm.DB) error
}

// DefaultStrictUpdateTCPSequence clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTCPSequence(ctx context.Context, in *TCPSequence, db *gorm.DB) (*TCPSequence, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTCPSequence")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TCPSequenceORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TCPSequenceORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TCPSequenceORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TCPSequenceORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TCPSequenceORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TCPSequenceORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TCPSequenceORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchTCPSequence executes a basic gorm update call with patch behavior
func DefaultPatchTCPSequence(ctx context.Context, in *TCPSequence, updateMask *field_mask.FieldMask, db *gorm.DB) (*TCPSequence, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj TCPSequence
	var err error
	if hook, ok := interface{}(&pbObj).(TCPSequenceWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTCPSequence(ctx, &TCPSequence{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TCPSequenceWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTCPSequence(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TCPSequenceWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTCPSequence(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TCPSequenceWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TCPSequenceWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *TCPSequence, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TCPSequenceWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *TCPSequence, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TCPSequenceWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *TCPSequence, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TCPSequenceWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *TCPSequence, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetTCPSequence executes a bulk gorm update call with patch behavior
func DefaultPatchSetTCPSequence(ctx context.Context, objects []*TCPSequence, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*TCPSequence, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*TCPSequence, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTCPSequence(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTCPSequence patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTCPSequence(ctx context.Context, patchee *TCPSequence, patcher *TCPSequence, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*TCPSequence, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Index" {
			patchee.Index = patcher.Index
			continue
		}
		if f == prefix+"Difficulty" {
			patchee.Difficulty = patcher.Difficulty
			continue
		}
		if f == prefix+"Values" {
			patchee.Values = patcher.Values
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTCPSequence executes a gorm list call
func DefaultListTCPSequence(ctx context.Context, db *gorm.DB) ([]*TCPSequence, error) {
	in := TCPSequence{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TCPSequenceORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TCPSequenceORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TCPSequenceORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TCPSequenceORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*TCPSequence{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TCPSequenceORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TCPSequenceORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TCPSequenceORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TCPSequenceORM) error
}

// DefaultCreateIPIDSequence executes a basic gorm create call
func DefaultCreateIPIDSequence(ctx context.Context, in *IPIDSequence, db *gorm.DB) (*IPIDSequence, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IPIDSequenceORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IPIDSequenceORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type IPIDSequenceORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IPIDSequenceORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadIPIDSequence(ctx context.Context, in *IPIDSequence, db *gorm.DB) (*IPIDSequence, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(IPIDSequenceORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(IPIDSequenceORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := IPIDSequenceORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(IPIDSequenceORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type IPIDSequenceORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IPIDSequenceORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IPIDSequenceORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteIPIDSequence(ctx context.Context, in *IPIDSequence, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(IPIDSequenceORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&IPIDSequenceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(IPIDSequenceORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type IPIDSequenceORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IPIDSequenceORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteIPIDSequenceSet(ctx context.Context, in []*IPIDSequence, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&IPIDSequenceORM{})).(IPIDSequenceORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&IPIDSequenceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&IPIDSequenceORM{})).(IPIDSequenceORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type IPIDSequenceORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*IPIDSequence, *gorm.DB) (*gorm.DB, error)
}
type IPIDSequenceORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*IPIDSequence, *gorm.DB) error
}

// DefaultStrictUpdateIPIDSequence clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateIPIDSequence(ctx context.Context, in *IPIDSequence, db *gorm.DB) (*IPIDSequence, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateIPIDSequence")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &IPIDSequenceORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(IPIDSequenceORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(IPIDSequenceORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IPIDSequenceORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type IPIDSequenceORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IPIDSequenceORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IPIDSequenceORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchIPIDSequence executes a basic gorm update call with patch behavior
func DefaultPatchIPIDSequence(ctx context.Context, in *IPIDSequence, updateMask *field_mask.FieldMask, db *gorm.DB) (*IPIDSequence, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj IPIDSequence
	var err error
	if hook, ok := interface{}(&pbObj).(IPIDSequenceWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadIPIDSequence(ctx, &IPIDSequence{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(IPIDSequenceWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskIPIDSequence(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(IPIDSequenceWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateIPIDSequence(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(IPIDSequenceWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type IPIDSequenceWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *IPIDSequence, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type IPIDSequenceWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *IPIDSequence, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type IPIDSequenceWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *IPIDSequence, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type IPIDSequenceWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *IPIDSequence, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetIPIDSequence executes a bulk gorm update call with patch behavior
func DefaultPatchSetIPIDSequence(ctx context.Context, objects []*IPIDSequence, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*IPIDSequence, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*IPIDSequence, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchIPIDSequence(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskIPIDSequence patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskIPIDSequence(ctx context.Context, patchee *IPIDSequence, patcher *IPIDSequence, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*IPIDSequence, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Index" {
			patchee.Index = patcher.Index
			continue
		}
		if f == prefix+"Difficulty" {
			patchee.Difficulty = patcher.Difficulty
			continue
		}
		if f == prefix+"Values" {
			patchee.Values = patcher.Values
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListIPIDSequence executes a gorm list call
func DefaultListIPIDSequence(ctx context.Context, db *gorm.DB) ([]*IPIDSequence, error) {
	in := IPIDSequence{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IPIDSequenceORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(IPIDSequenceORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []IPIDSequenceORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IPIDSequenceORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*IPIDSequence{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type IPIDSequenceORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IPIDSequenceORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IPIDSequenceORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]IPIDSequenceORM) error
}

// DefaultCreateTCPTSSequence executes a basic gorm create call
func DefaultCreateTCPTSSequence(ctx context.Context, in *TCPTSSequence, db *gorm.DB) (*TCPTSSequence, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TCPTSSequenceORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TCPTSSequenceORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TCPTSSequenceORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TCPTSSequenceORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadTCPTSSequence(ctx context.Context, in *TCPTSSequence, db *gorm.DB) (*TCPTSSequence, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TCPTSSequenceORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TCPTSSequenceORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TCPTSSequenceORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TCPTSSequenceORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TCPTSSequenceORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TCPTSSequenceORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TCPTSSequenceORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteTCPTSSequence(ctx context.Context, in *TCPTSSequence, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TCPTSSequenceORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TCPTSSequenceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TCPTSSequenceORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TCPTSSequenceORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TCPTSSequenceORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteTCPTSSequenceSet(ctx context.Context, in []*TCPTSSequence, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TCPTSSequenceORM{})).(TCPTSSequenceORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TCPTSSequenceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TCPTSSequenceORM{})).(TCPTSSequenceORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TCPTSSequenceORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*TCPTSSequence, *gorm.DB) (*gorm.DB, error)
}
type TCPTSSequenceORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*TCPTSSequence, *gorm.DB) error
}

// DefaultStrictUpdateTCPTSSequence clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTCPTSSequence(ctx context.Context, in *TCPTSSequence, db *gorm.DB) (*TCPTSSequence, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTCPTSSequence")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TCPTSSequenceORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TCPTSSequenceORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TCPTSSequenceORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TCPTSSequenceORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TCPTSSequenceORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TCPTSSequenceORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TCPTSSequenceORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchTCPTSSequence executes a basic gorm update call with patch behavior
func DefaultPatchTCPTSSequence(ctx context.Context, in *TCPTSSequence, updateMask *field_mask.FieldMask, db *gorm.DB) (*TCPTSSequence, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj TCPTSSequence
	var err error
	if hook, ok := interface{}(&pbObj).(TCPTSSequenceWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTCPTSSequence(ctx, &TCPTSSequence{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TCPTSSequenceWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTCPTSSequence(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TCPTSSequenceWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTCPTSSequence(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TCPTSSequenceWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TCPTSSequenceWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *TCPTSSequence, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TCPTSSequenceWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *TCPTSSequence, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TCPTSSequenceWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *TCPTSSequence, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TCPTSSequenceWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *TCPTSSequence, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetTCPTSSequence executes a bulk gorm update call with patch behavior
func DefaultPatchSetTCPTSSequence(ctx context.Context, objects []*TCPTSSequence, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*TCPTSSequence, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*TCPTSSequence, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTCPTSSequence(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTCPTSSequence patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTCPTSSequence(ctx context.Context, patchee *TCPTSSequence, patcher *TCPTSSequence, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*TCPTSSequence, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Index" {
			patchee.Index = patcher.Index
			continue
		}
		if f == prefix+"Difficulty" {
			patchee.Difficulty = patcher.Difficulty
			continue
		}
		if f == prefix+"Values" {
			patchee.Values = patcher.Values
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTCPTSSequence executes a gorm list call
func DefaultListTCPTSSequence(ctx context.Context, db *gorm.DB) ([]*TCPTSSequence, error) {
	in := TCPTSSequence{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TCPTSSequenceORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TCPTSSequenceORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TCPTSSequenceORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TCPTSSequenceORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*TCPTSSequence{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TCPTSSequenceORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TCPTSSequenceORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TCPTSSequenceORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TCPTSSequenceORM) error
}

// DefaultCreateICMPResponse executes a basic gorm create call
func DefaultCreateICMPResponse(ctx context.Context, in *ICMPResponse, db *gorm.DB) (*ICMPResponse, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ICMPResponseORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ICMPResponseORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ICMPResponseORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ICMPResponseORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadICMPResponse(ctx context.Context, in *ICMPResponse, db *gorm.DB) (*ICMPResponse, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ICMPResponseORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ICMPResponseORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ICMPResponseORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ICMPResponseORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ICMPResponseORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ICMPResponseORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ICMPResponseORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteICMPResponse(ctx context.Context, in *ICMPResponse, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ICMPResponseORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ICMPResponseORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ICMPResponseORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ICMPResponseORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ICMPResponseORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteICMPResponseSet(ctx context.Context, in []*ICMPResponse, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ICMPResponseORM{})).(ICMPResponseORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ICMPResponseORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ICMPResponseORM{})).(ICMPResponseORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ICMPResponseORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ICMPResponse, *gorm.DB) (*gorm.DB, error)
}
type ICMPResponseORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ICMPResponse, *gorm.DB) error
}

// DefaultStrictUpdateICMPResponse clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateICMPResponse(ctx context.Context, in *ICMPResponse, db *gorm.DB) (*ICMPResponse, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateICMPResponse")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ICMPResponseORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ICMPResponseORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ICMPResponseORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ICMPResponseORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ICMPResponseORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ICMPResponseORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ICMPResponseORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchICMPResponse executes a basic gorm update call with patch behavior
func DefaultPatchICMPResponse(ctx context.Context, in *ICMPResponse, updateMask *field_mask.FieldMask, db *gorm.DB) (*ICMPResponse, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj ICMPResponse
	var err error
	if hook, ok := interface{}(&pbObj).(ICMPResponseWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadICMPResponse(ctx, &ICMPResponse{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ICMPResponseWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskICMPResponse(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ICMPResponseWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateICMPResponse(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ICMPResponseWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ICMPResponseWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ICMPResponse, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ICMPResponseWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ICMPResponse, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ICMPResponseWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ICMPResponse, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ICMPResponseWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ICMPResponse, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetICMPResponse executes a bulk gorm update call with patch behavior
func DefaultPatchSetICMPResponse(ctx context.Context, objects []*ICMPResponse, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*ICMPResponse, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ICMPResponse, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchICMPResponse(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskICMPResponse patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskICMPResponse(ctx context.Context, patchee *ICMPResponse, patcher *ICMPResponse, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*ICMPResponse, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"Code" {
			patchee.Code = patcher.Code
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListICMPResponse executes a gorm list call
func DefaultListICMPResponse(ctx context.Context, db *gorm.DB) ([]*ICMPResponse, error) {
	in := ICMPResponse{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ICMPResponseORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ICMPResponseORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ICMPResponseORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ICMPResponseORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ICMPResponse{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ICMPResponseORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ICMPResponseORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ICMPResponseORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ICMPResponseORM) error
}
