package host

import (
	context "context"
	fmt "fmt"
	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	types "github.com/infobloxopen/protoc-gen-gorm/types"
	gorm "github.com/jinzhu/gorm"
	network "github.com/maxlandon/aims/proto/gen/go/network"
	scan "github.com/maxlandon/aims/proto/gen/go/scan"
	go_uuid "github.com/satori/go.uuid"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	strings "strings"
	time "time"
)

type PortORM struct {
	Count            int32
	CreatedAt        *time.Time
	ExtraPortsHostId *go_uuid.UUID
	Id               go_uuid.UUID `gorm:"type:uuid;primary_key"`
	Number           uint32
	Owner            string
	PortsHostId      *go_uuid.UUID
	Protocol         string
	Reasons          []*ReasonORM          `gorm:"foreignkey:PortId;association_foreignkey:Id"`
	Scripts          []*scan.NmapScriptORM `gorm:"foreignkey:Id;association_foreignkey:Id;many2many:port_nmap_scripts;jointable_foreignkey:PortId;association_jointable_foreignkey:NmapScriptId"`
	Service          *network.ServiceORM   `gorm:"foreignkey:ServiceId;association_foreignkey:Id"`
	ServiceId        *go_uuid.UUID
	State            *StateORM `gorm:"foreignkey:PortId;association_foreignkey:Id"`
	UpdatedAt        *time.Time
}

// TableName overrides the default tablename generated by GORM
func (PortORM) TableName() string {
	return "ports"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Port) ToORM(ctx context.Context) (PortORM, error) {
	to := PortORM{}
	var err error
	if prehook, ok := interface{}(m).(PortWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if m.Id != nil {
		to.Id, err = go_uuid.FromString(m.Id.Value)
		if err != nil {
			return to, err
		}
	} else {
		to.Id = go_uuid.Nil
	}
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	to.Number = m.Number
	to.Protocol = m.Protocol
	to.Owner = m.Owner
	if m.Service != nil {
		tempService, err := m.Service.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Service = &tempService
	}
	if m.State != nil {
		tempState, err := m.State.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.State = &tempState
	}
	for _, v := range m.Scripts {
		if v != nil {
			if tempScripts, cErr := v.ToORM(ctx); cErr == nil {
				to.Scripts = append(to.Scripts, &tempScripts)
			} else {
				return to, cErr
			}
		} else {
			to.Scripts = append(to.Scripts, nil)
		}
	}
	to.Count = m.Count
	for _, v := range m.Reasons {
		if v != nil {
			if tempReasons, cErr := v.ToORM(ctx); cErr == nil {
				to.Reasons = append(to.Reasons, &tempReasons)
			} else {
				return to, cErr
			}
		} else {
			to.Reasons = append(to.Reasons, nil)
		}
	}
	if posthook, ok := interface{}(m).(PortWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PortORM) ToPB(ctx context.Context) (Port, error) {
	to := Port{}
	var err error
	if prehook, ok := interface{}(m).(PortWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = &types.UUID{Value: m.Id.String()}
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	to.Number = m.Number
	to.Protocol = m.Protocol
	to.Owner = m.Owner
	if m.Service != nil {
		tempService, err := m.Service.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Service = &tempService
	}
	if m.State != nil {
		tempState, err := m.State.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.State = &tempState
	}
	for _, v := range m.Scripts {
		if v != nil {
			if tempScripts, cErr := v.ToPB(ctx); cErr == nil {
				to.Scripts = append(to.Scripts, &tempScripts)
			} else {
				return to, cErr
			}
		} else {
			to.Scripts = append(to.Scripts, nil)
		}
	}
	to.Count = m.Count
	for _, v := range m.Reasons {
		if v != nil {
			if tempReasons, cErr := v.ToPB(ctx); cErr == nil {
				to.Reasons = append(to.Reasons, &tempReasons)
			} else {
				return to, cErr
			}
		} else {
			to.Reasons = append(to.Reasons, nil)
		}
	}
	if posthook, ok := interface{}(m).(PortWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Port the arg will be the target, the caller the one being converted from

// PortBeforeToORM called before default ToORM code
type PortWithBeforeToORM interface {
	BeforeToORM(context.Context, *PortORM) error
}

// PortAfterToORM called after default ToORM code
type PortWithAfterToORM interface {
	AfterToORM(context.Context, *PortORM) error
}

// PortBeforeToPB called before default ToPB code
type PortWithBeforeToPB interface {
	BeforeToPB(context.Context, *Port) error
}

// PortAfterToPB called after default ToPB code
type PortWithAfterToPB interface {
	AfterToPB(context.Context, *Port) error
}

type ReasonORM struct {
	Count  int32
	PortId *go_uuid.UUID
	Reason string
}

// TableName overrides the default tablename generated by GORM
func (ReasonORM) TableName() string {
	return "reasons"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Reason) ToORM(ctx context.Context) (ReasonORM, error) {
	to := ReasonORM{}
	var err error
	if prehook, ok := interface{}(m).(ReasonWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Reason = m.Reason
	to.Count = m.Count
	if posthook, ok := interface{}(m).(ReasonWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ReasonORM) ToPB(ctx context.Context) (Reason, error) {
	to := Reason{}
	var err error
	if prehook, ok := interface{}(m).(ReasonWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Reason = m.Reason
	to.Count = m.Count
	if posthook, ok := interface{}(m).(ReasonWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Reason the arg will be the target, the caller the one being converted from

// ReasonBeforeToORM called before default ToORM code
type ReasonWithBeforeToORM interface {
	BeforeToORM(context.Context, *ReasonORM) error
}

// ReasonAfterToORM called after default ToORM code
type ReasonWithAfterToORM interface {
	AfterToORM(context.Context, *ReasonORM) error
}

// ReasonBeforeToPB called before default ToPB code
type ReasonWithBeforeToPB interface {
	BeforeToPB(context.Context, *Reason) error
}

// ReasonAfterToPB called after default ToPB code
type ReasonWithAfterToPB interface {
	AfterToPB(context.Context, *Reason) error
}

type StateORM struct {
	CreatedAt *time.Time
	Id        go_uuid.UUID `gorm:"type:uuid;primary_key"`
	PortId    *go_uuid.UUID
	Reason    string
	ReasonIP  string
	ReasonTTL float32
	State     string
	UpdatedAt *time.Time
}

// TableName overrides the default tablename generated by GORM
func (StateORM) TableName() string {
	return "states"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *State) ToORM(ctx context.Context) (StateORM, error) {
	to := StateORM{}
	var err error
	if prehook, ok := interface{}(m).(StateWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if m.Id != nil {
		to.Id, err = go_uuid.FromString(m.Id.Value)
		if err != nil {
			return to, err
		}
	} else {
		to.Id = go_uuid.Nil
	}
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	to.State = m.State
	to.Reason = m.Reason
	to.ReasonIP = m.ReasonIP
	to.ReasonTTL = m.ReasonTTL
	if posthook, ok := interface{}(m).(StateWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *StateORM) ToPB(ctx context.Context) (State, error) {
	to := State{}
	var err error
	if prehook, ok := interface{}(m).(StateWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = &types.UUID{Value: m.Id.String()}
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	to.State = m.State
	to.Reason = m.Reason
	to.ReasonIP = m.ReasonIP
	to.ReasonTTL = m.ReasonTTL
	if posthook, ok := interface{}(m).(StateWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type State the arg will be the target, the caller the one being converted from

// StateBeforeToORM called before default ToORM code
type StateWithBeforeToORM interface {
	BeforeToORM(context.Context, *StateORM) error
}

// StateAfterToORM called after default ToORM code
type StateWithAfterToORM interface {
	AfterToORM(context.Context, *StateORM) error
}

// StateBeforeToPB called before default ToPB code
type StateWithBeforeToPB interface {
	BeforeToPB(context.Context, *State) error
}

// StateAfterToPB called after default ToPB code
type StateWithAfterToPB interface {
	AfterToPB(context.Context, *State) error
}

// DefaultCreatePort executes a basic gorm create call
func DefaultCreatePort(ctx context.Context, in *Port, db *gorm.DB) (*Port, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PortORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PortORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PortORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PortORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPort(ctx context.Context, in *Port, db *gorm.DB) (*Port, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == go_uuid.Nil {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PortORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &PortORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PortORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PortORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PortORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PortORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PortORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PortORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePort(ctx context.Context, in *Port, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == go_uuid.Nil {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PortORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PortORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PortORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PortORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PortORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePortSet(ctx context.Context, in []*Port, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []go_uuid.UUID{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == go_uuid.Nil {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PortORM{})).(PortORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PortORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PortORM{})).(PortORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PortORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Port, *gorm.DB) (*gorm.DB, error)
}
type PortORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Port, *gorm.DB) error
}

// DefaultStrictUpdatePort clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePort(ctx context.Context, in *Port, db *gorm.DB) (*Port, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePort")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PortORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PortORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterReasons := ReasonORM{}
	if ormObj.Id == go_uuid.Nil {
		return nil, errors.EmptyIdError
	}
	filterReasons.PortId = new(go_uuid.UUID)
	*filterReasons.PortId = ormObj.Id
	if err = db.Where(filterReasons).Delete(ReasonORM{}).Error; err != nil {
		return nil, err
	}
	if err = db.Model(&ormObj).Association("Scripts").Replace(ormObj.Scripts).Error; err != nil {
		return nil, err
	}
	ormObj.Scripts = nil
	filterState := StateORM{}
	if ormObj.Id == go_uuid.Nil {
		return nil, errors.EmptyIdError
	}
	filterState.PortId = new(go_uuid.UUID)
	*filterState.PortId = ormObj.Id
	if err = db.Where(filterState).Delete(StateORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PortORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PortORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PortORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PortORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PortORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPort executes a basic gorm update call with patch behavior
func DefaultPatchPort(ctx context.Context, in *Port, updateMask *field_mask.FieldMask, db *gorm.DB) (*Port, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Port
	var err error
	if hook, ok := interface{}(&pbObj).(PortWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPort(ctx, &Port{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PortWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPort(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PortWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePort(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PortWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PortWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Port, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PortWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Port, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PortWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Port, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PortWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Port, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPort executes a bulk gorm update call with patch behavior
func DefaultPatchSetPort(ctx context.Context, objects []*Port, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Port, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Port, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPort(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPort patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPort(ctx context.Context, patchee *Port, patcher *Port, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Port, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedService bool
	var updatedState bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"Number" {
			patchee.Number = patcher.Number
			continue
		}
		if f == prefix+"Protocol" {
			patchee.Protocol = patcher.Protocol
			continue
		}
		if f == prefix+"Owner" {
			patchee.Owner = patcher.Owner
			continue
		}
		if !updatedService && strings.HasPrefix(f, prefix+"Service.") {
			updatedService = true
			if patcher.Service == nil {
				patchee.Service = nil
				continue
			}
			if patchee.Service == nil {
				patchee.Service = &network.Service{}
			}
			if o, err := network.DefaultApplyFieldMaskService(ctx, patchee.Service, patcher.Service, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Service.", db); err != nil {
				return nil, err
			} else {
				patchee.Service = o
			}
			continue
		}
		if f == prefix+"Service" {
			updatedService = true
			patchee.Service = patcher.Service
			continue
		}
		if !updatedState && strings.HasPrefix(f, prefix+"State.") {
			updatedState = true
			if patcher.State == nil {
				patchee.State = nil
				continue
			}
			if patchee.State == nil {
				patchee.State = &State{}
			}
			if o, err := DefaultApplyFieldMaskState(ctx, patchee.State, patcher.State, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"State.", db); err != nil {
				return nil, err
			} else {
				patchee.State = o
			}
			continue
		}
		if f == prefix+"State" {
			updatedState = true
			patchee.State = patcher.State
			continue
		}
		if f == prefix+"Scripts" {
			patchee.Scripts = patcher.Scripts
			continue
		}
		if f == prefix+"Count" {
			patchee.Count = patcher.Count
			continue
		}
		if f == prefix+"Reasons" {
			patchee.Reasons = patcher.Reasons
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPort executes a gorm list call
func DefaultListPort(ctx context.Context, db *gorm.DB) ([]*Port, error) {
	in := Port{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PortORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &PortORM{}, &Port{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PortORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PortORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PortORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Port{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PortORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PortORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PortORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PortORM) error
}

// DefaultCreateReason executes a basic gorm create call
func DefaultCreateReason(ctx context.Context, in *Reason, db *gorm.DB) (*Reason, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReasonORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReasonORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ReasonORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReasonORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

// DefaultApplyFieldMaskReason patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskReason(ctx context.Context, patchee *Reason, patcher *Reason, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Reason, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Reason" {
			patchee.Reason = patcher.Reason
			continue
		}
		if f == prefix+"Count" {
			patchee.Count = patcher.Count
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListReason executes a gorm list call
func DefaultListReason(ctx context.Context, db *gorm.DB) ([]*Reason, error) {
	in := Reason{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReasonORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &ReasonORM{}, &Reason{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReasonORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []ReasonORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReasonORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Reason{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ReasonORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReasonORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReasonORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ReasonORM) error
}

// DefaultCreateState executes a basic gorm create call
func DefaultCreateState(ctx context.Context, in *State, db *gorm.DB) (*State, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StateORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StateORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type StateORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StateORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadState(ctx context.Context, in *State, db *gorm.DB) (*State, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == go_uuid.Nil {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(StateORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &StateORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StateORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := StateORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(StateORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type StateORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StateORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StateORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteState(ctx context.Context, in *State, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == go_uuid.Nil {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(StateORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&StateORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(StateORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type StateORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StateORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteStateSet(ctx context.Context, in []*State, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []go_uuid.UUID{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == go_uuid.Nil {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&StateORM{})).(StateORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&StateORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&StateORM{})).(StateORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type StateORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*State, *gorm.DB) (*gorm.DB, error)
}
type StateORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*State, *gorm.DB) error
}

// DefaultStrictUpdateState clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateState(ctx context.Context, in *State, db *gorm.DB) (*State, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateState")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &StateORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(StateORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(StateORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StateORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type StateORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StateORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StateORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchState executes a basic gorm update call with patch behavior
func DefaultPatchState(ctx context.Context, in *State, updateMask *field_mask.FieldMask, db *gorm.DB) (*State, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj State
	var err error
	if hook, ok := interface{}(&pbObj).(StateWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadState(ctx, &State{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(StateWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskState(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(StateWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateState(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(StateWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type StateWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *State, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type StateWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *State, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type StateWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *State, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type StateWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *State, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetState executes a bulk gorm update call with patch behavior
func DefaultPatchSetState(ctx context.Context, objects []*State, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*State, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*State, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchState(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskState patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskState(ctx context.Context, patchee *State, patcher *State, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*State, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"State" {
			patchee.State = patcher.State
			continue
		}
		if f == prefix+"Reason" {
			patchee.Reason = patcher.Reason
			continue
		}
		if f == prefix+"ReasonIP" {
			patchee.ReasonIP = patcher.ReasonIP
			continue
		}
		if f == prefix+"ReasonTTL" {
			patchee.ReasonTTL = patcher.ReasonTTL
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListState executes a gorm list call
func DefaultListState(ctx context.Context, db *gorm.DB) ([]*State, error) {
	in := State{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StateORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &StateORM{}, &State{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StateORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []StateORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StateORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*State{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type StateORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StateORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StateORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]StateORM) error
}
