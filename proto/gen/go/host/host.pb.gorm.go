package host

import (
	context "context"
	fmt "fmt"
	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	types "github.com/infobloxopen/protoc-gen-gorm/types"
	gorm "github.com/jinzhu/gorm"
	network "github.com/maxlandon/aims/proto/gen/go/network"
	nmap "github.com/maxlandon/aims/proto/gen/go/scan/nmap"
	go_uuid "github.com/satori/go.uuid"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	strings "strings"
	time "time"
)

type HostORM struct {
	Addresses       []*network.AddressORM `gorm:"foreignkey:Id;association_foreignkey:Id;many2many:host_addresses;jointable_foreignkey:HostId;association_jointable_foreignkey:AddressId"`
	Arch            string
	Comm            string
	Comment         string
	CreatedAt       *time.Time
	Distance        *network.DistanceORM `gorm:"foreignkey:DistanceId;association_foreignkey:Id"`
	DistanceId      *go_uuid.UUID
	EndTime         int64
	ExtraPorts      []*ExtraPortORM          `gorm:"foreignkey:HostId;association_foreignkey:Id"`
	HostScripts     []*nmap.ScriptORM        `gorm:"foreignkey:Id;association_foreignkey:Id;many2many:host_scripts;jointable_foreignkey:HostId;association_jointable_foreignkey:ScriptId"`
	Hostnames       []*HostnameORM           `gorm:"foreignkey:HostId;association_foreignkey:Id"`
	IPIDSequence    *network.IPIDSequenceORM `gorm:"foreignkey:IPIDSequenceId;association_foreignkey:Id"`
	IPIDSequenceId  *go_uuid.UUID
	Id              go_uuid.UUID `gorm:"type:uuid;primary_key"`
	Info            string
	MAC             string
	OSFamily        string
	OSFlavor        string
	OSLang          string
	OSName          string
	OSSp            string
	Ports           []*PortORM `gorm:"foreignkey:HostId;association_foreignkey:Id"`
	Purpose         string
	Scope           string
	Smurfs          []*nmap.SmurfORM `gorm:"foreignkey:Id;association_foreignkey:Id;many2many:host_smurves;jointable_foreignkey:HostId;association_jointable_foreignkey:SmurfId"`
	StartTime       int64
	Status          *StatusORM              `gorm:"foreignkey:HostId;association_foreignkey:Id"`
	TCPSequence     *network.TCPSequenceORM `gorm:"foreignkey:TCPSequenceId;association_foreignkey:Id"`
	TCPSequenceId   *go_uuid.UUID
	TCPTSSequence   *network.TCPTSSequenceORM `gorm:"foreignkey:TCPTSSequenceId;association_foreignkey:Id"`
	TCPTSSequenceId *go_uuid.UUID
	Times           *network.TimesORM `gorm:"foreignkey:TimesId;association_foreignkey:Id"`
	TimesId         *go_uuid.UUID
	Trace           *network.TraceORM `gorm:"foreignkey:TraceId;association_foreignkey:Id"`
	TraceId         *go_uuid.UUID
	UpdatedAt       *time.Time
	Users           []*UserORM `gorm:"foreignkey:HostId;association_foreignkey:Id"`
	VirtualHost     string
}

// TableName overrides the default tablename generated by GORM
func (HostORM) TableName() string {
	return "hosts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Host) ToORM(ctx context.Context) (HostORM, error) {
	to := HostORM{}
	var err error
	if prehook, ok := interface{}(m).(HostWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if m.Id != nil {
		to.Id, err = go_uuid.FromString(m.Id.Value)
		if err != nil {
			return to, err
		}
	} else {
		to.Id = go_uuid.Nil
	}
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	to.MAC = m.MAC
	to.Comm = m.Comm
	to.OSName = m.OSName
	to.OSFlavor = m.OSFlavor
	to.OSSp = m.OSSp
	to.OSLang = m.OSLang
	to.OSFamily = m.OSFamily
	to.Arch = m.Arch
	to.Purpose = m.Purpose
	to.Info = m.Info
	to.Scope = m.Scope
	to.VirtualHost = m.VirtualHost
	for _, v := range m.Users {
		if v != nil {
			if tempUsers, cErr := v.ToORM(ctx); cErr == nil {
				to.Users = append(to.Users, &tempUsers)
			} else {
				return to, cErr
			}
		} else {
			to.Users = append(to.Users, nil)
		}
	}
	for _, v := range m.Addresses {
		if v != nil {
			if tempAddresses, cErr := v.ToORM(ctx); cErr == nil {
				to.Addresses = append(to.Addresses, &tempAddresses)
			} else {
				return to, cErr
			}
		} else {
			to.Addresses = append(to.Addresses, nil)
		}
	}
	if m.Status != nil {
		tempStatus, err := m.Status.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Status = &tempStatus
	}
	if m.Distance != nil {
		tempDistance, err := m.Distance.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Distance = &tempDistance
	}
	to.StartTime = m.StartTime
	to.EndTime = m.EndTime
	if m.IPIDSequence != nil {
		tempIPIDSequence, err := m.IPIDSequence.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.IPIDSequence = &tempIPIDSequence
	}
	if m.TCPSequence != nil {
		tempTCPSequence, err := m.TCPSequence.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.TCPSequence = &tempTCPSequence
	}
	if m.TCPTSSequence != nil {
		tempTCPTSSequence, err := m.TCPTSSequence.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.TCPTSSequence = &tempTCPTSSequence
	}
	if m.Times != nil {
		tempTimes, err := m.Times.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Times = &tempTimes
	}
	if m.Trace != nil {
		tempTrace, err := m.Trace.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Trace = &tempTrace
	}
	to.Comment = m.Comment
	for _, v := range m.HostScripts {
		if v != nil {
			if tempHostScripts, cErr := v.ToORM(ctx); cErr == nil {
				to.HostScripts = append(to.HostScripts, &tempHostScripts)
			} else {
				return to, cErr
			}
		} else {
			to.HostScripts = append(to.HostScripts, nil)
		}
	}
	for _, v := range m.Smurfs {
		if v != nil {
			if tempSmurfs, cErr := v.ToORM(ctx); cErr == nil {
				to.Smurfs = append(to.Smurfs, &tempSmurfs)
			} else {
				return to, cErr
			}
		} else {
			to.Smurfs = append(to.Smurfs, nil)
		}
	}
	for _, v := range m.Hostnames {
		if v != nil {
			if tempHostnames, cErr := v.ToORM(ctx); cErr == nil {
				to.Hostnames = append(to.Hostnames, &tempHostnames)
			} else {
				return to, cErr
			}
		} else {
			to.Hostnames = append(to.Hostnames, nil)
		}
	}
	for _, v := range m.Ports {
		if v != nil {
			if tempPorts, cErr := v.ToORM(ctx); cErr == nil {
				to.Ports = append(to.Ports, &tempPorts)
			} else {
				return to, cErr
			}
		} else {
			to.Ports = append(to.Ports, nil)
		}
	}
	for _, v := range m.ExtraPorts {
		if v != nil {
			if tempExtraPorts, cErr := v.ToORM(ctx); cErr == nil {
				to.ExtraPorts = append(to.ExtraPorts, &tempExtraPorts)
			} else {
				return to, cErr
			}
		} else {
			to.ExtraPorts = append(to.ExtraPorts, nil)
		}
	}
	if posthook, ok := interface{}(m).(HostWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *HostORM) ToPB(ctx context.Context) (Host, error) {
	to := Host{}
	var err error
	if prehook, ok := interface{}(m).(HostWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = &types.UUID{Value: m.Id.String()}
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	to.MAC = m.MAC
	to.Comm = m.Comm
	to.OSName = m.OSName
	to.OSFlavor = m.OSFlavor
	to.OSSp = m.OSSp
	to.OSLang = m.OSLang
	to.OSFamily = m.OSFamily
	to.Arch = m.Arch
	to.Purpose = m.Purpose
	to.Info = m.Info
	to.Scope = m.Scope
	to.VirtualHost = m.VirtualHost
	for _, v := range m.Users {
		if v != nil {
			if tempUsers, cErr := v.ToPB(ctx); cErr == nil {
				to.Users = append(to.Users, &tempUsers)
			} else {
				return to, cErr
			}
		} else {
			to.Users = append(to.Users, nil)
		}
	}
	for _, v := range m.Addresses {
		if v != nil {
			if tempAddresses, cErr := v.ToPB(ctx); cErr == nil {
				to.Addresses = append(to.Addresses, &tempAddresses)
			} else {
				return to, cErr
			}
		} else {
			to.Addresses = append(to.Addresses, nil)
		}
	}
	if m.Status != nil {
		tempStatus, err := m.Status.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Status = &tempStatus
	}
	if m.Distance != nil {
		tempDistance, err := m.Distance.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Distance = &tempDistance
	}
	to.StartTime = m.StartTime
	to.EndTime = m.EndTime
	if m.IPIDSequence != nil {
		tempIPIDSequence, err := m.IPIDSequence.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.IPIDSequence = &tempIPIDSequence
	}
	if m.TCPSequence != nil {
		tempTCPSequence, err := m.TCPSequence.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.TCPSequence = &tempTCPSequence
	}
	if m.TCPTSSequence != nil {
		tempTCPTSSequence, err := m.TCPTSSequence.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.TCPTSSequence = &tempTCPTSSequence
	}
	if m.Times != nil {
		tempTimes, err := m.Times.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Times = &tempTimes
	}
	if m.Trace != nil {
		tempTrace, err := m.Trace.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Trace = &tempTrace
	}
	to.Comment = m.Comment
	for _, v := range m.HostScripts {
		if v != nil {
			if tempHostScripts, cErr := v.ToPB(ctx); cErr == nil {
				to.HostScripts = append(to.HostScripts, &tempHostScripts)
			} else {
				return to, cErr
			}
		} else {
			to.HostScripts = append(to.HostScripts, nil)
		}
	}
	for _, v := range m.Smurfs {
		if v != nil {
			if tempSmurfs, cErr := v.ToPB(ctx); cErr == nil {
				to.Smurfs = append(to.Smurfs, &tempSmurfs)
			} else {
				return to, cErr
			}
		} else {
			to.Smurfs = append(to.Smurfs, nil)
		}
	}
	for _, v := range m.Hostnames {
		if v != nil {
			if tempHostnames, cErr := v.ToPB(ctx); cErr == nil {
				to.Hostnames = append(to.Hostnames, &tempHostnames)
			} else {
				return to, cErr
			}
		} else {
			to.Hostnames = append(to.Hostnames, nil)
		}
	}
	for _, v := range m.Ports {
		if v != nil {
			if tempPorts, cErr := v.ToPB(ctx); cErr == nil {
				to.Ports = append(to.Ports, &tempPorts)
			} else {
				return to, cErr
			}
		} else {
			to.Ports = append(to.Ports, nil)
		}
	}
	for _, v := range m.ExtraPorts {
		if v != nil {
			if tempExtraPorts, cErr := v.ToPB(ctx); cErr == nil {
				to.ExtraPorts = append(to.ExtraPorts, &tempExtraPorts)
			} else {
				return to, cErr
			}
		} else {
			to.ExtraPorts = append(to.ExtraPorts, nil)
		}
	}
	if posthook, ok := interface{}(m).(HostWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Host the arg will be the target, the caller the one being converted from

// HostBeforeToORM called before default ToORM code
type HostWithBeforeToORM interface {
	BeforeToORM(context.Context, *HostORM) error
}

// HostAfterToORM called after default ToORM code
type HostWithAfterToORM interface {
	AfterToORM(context.Context, *HostORM) error
}

// HostBeforeToPB called before default ToPB code
type HostWithBeforeToPB interface {
	BeforeToPB(context.Context, *Host) error
}

// HostAfterToPB called after default ToPB code
type HostWithAfterToPB interface {
	AfterToPB(context.Context, *Host) error
}

type HostnameORM struct {
	CreatedAt *time.Time
	HostId    *go_uuid.UUID
	Id        go_uuid.UUID `gorm:"type:uuid;primary_key"`
	Name      string
	Type      string
	UpdatedAt *time.Time
}

// TableName overrides the default tablename generated by GORM
func (HostnameORM) TableName() string {
	return "hostnames"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Hostname) ToORM(ctx context.Context) (HostnameORM, error) {
	to := HostnameORM{}
	var err error
	if prehook, ok := interface{}(m).(HostnameWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if m.Id != nil {
		to.Id, err = go_uuid.FromString(m.Id.Value)
		if err != nil {
			return to, err
		}
	} else {
		to.Id = go_uuid.Nil
	}
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	to.Name = m.Name
	to.Type = m.Type
	if posthook, ok := interface{}(m).(HostnameWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *HostnameORM) ToPB(ctx context.Context) (Hostname, error) {
	to := Hostname{}
	var err error
	if prehook, ok := interface{}(m).(HostnameWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = &types.UUID{Value: m.Id.String()}
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	to.Name = m.Name
	to.Type = m.Type
	if posthook, ok := interface{}(m).(HostnameWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Hostname the arg will be the target, the caller the one being converted from

// HostnameBeforeToORM called before default ToORM code
type HostnameWithBeforeToORM interface {
	BeforeToORM(context.Context, *HostnameORM) error
}

// HostnameAfterToORM called after default ToORM code
type HostnameWithAfterToORM interface {
	AfterToORM(context.Context, *HostnameORM) error
}

// HostnameBeforeToPB called before default ToPB code
type HostnameWithBeforeToPB interface {
	BeforeToPB(context.Context, *Hostname) error
}

// HostnameAfterToPB called after default ToPB code
type HostnameWithAfterToPB interface {
	AfterToPB(context.Context, *Hostname) error
}

type StatusORM struct {
	HostId    *go_uuid.UUID
	Reason    string
	ReasonTTL string
	State     string
}

// TableName overrides the default tablename generated by GORM
func (StatusORM) TableName() string {
	return "statuses"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Status) ToORM(ctx context.Context) (StatusORM, error) {
	to := StatusORM{}
	var err error
	if prehook, ok := interface{}(m).(StatusWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.State = m.State
	to.Reason = m.Reason
	to.ReasonTTL = m.ReasonTTL
	if posthook, ok := interface{}(m).(StatusWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *StatusORM) ToPB(ctx context.Context) (Status, error) {
	to := Status{}
	var err error
	if prehook, ok := interface{}(m).(StatusWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.State = m.State
	to.Reason = m.Reason
	to.ReasonTTL = m.ReasonTTL
	if posthook, ok := interface{}(m).(StatusWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Status the arg will be the target, the caller the one being converted from

// StatusBeforeToORM called before default ToORM code
type StatusWithBeforeToORM interface {
	BeforeToORM(context.Context, *StatusORM) error
}

// StatusAfterToORM called after default ToORM code
type StatusWithAfterToORM interface {
	AfterToORM(context.Context, *StatusORM) error
}

// StatusBeforeToPB called before default ToPB code
type StatusWithBeforeToPB interface {
	BeforeToPB(context.Context, *Status) error
}

// StatusAfterToPB called after default ToPB code
type StatusWithAfterToPB interface {
	AfterToPB(context.Context, *Status) error
}

// DefaultCreateHost executes a basic gorm create call
func DefaultCreateHost(ctx context.Context, in *Host, db *gorm.DB) (*Host, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type HostORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadHost(ctx context.Context, in *Host, db *gorm.DB) (*Host, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == go_uuid.Nil {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(HostORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &HostORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := HostORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(HostORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type HostORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteHost(ctx context.Context, in *Host, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == go_uuid.Nil {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(HostORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&HostORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(HostORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type HostORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteHostSet(ctx context.Context, in []*Host, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []go_uuid.UUID{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == go_uuid.Nil {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&HostORM{})).(HostORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&HostORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&HostORM{})).(HostORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type HostORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Host, *gorm.DB) (*gorm.DB, error)
}
type HostORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Host, *gorm.DB) error
}

// DefaultStrictUpdateHost clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateHost(ctx context.Context, in *Host, db *gorm.DB) (*Host, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateHost")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &HostORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(HostORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Model(&ormObj).Association("Addresses").Replace(ormObj.Addresses).Error; err != nil {
		return nil, err
	}
	ormObj.Addresses = nil
	filterExtraPorts := ExtraPortORM{}
	if ormObj.Id == go_uuid.Nil {
		return nil, errors.EmptyIdError
	}
	filterExtraPorts.HostId = new(go_uuid.UUID)
	*filterExtraPorts.HostId = ormObj.Id
	if err = db.Where(filterExtraPorts).Delete(ExtraPortORM{}).Error; err != nil {
		return nil, err
	}
	if err = db.Model(&ormObj).Association("HostScripts").Replace(ormObj.HostScripts).Error; err != nil {
		return nil, err
	}
	ormObj.HostScripts = nil
	filterHostnames := HostnameORM{}
	if ormObj.Id == go_uuid.Nil {
		return nil, errors.EmptyIdError
	}
	filterHostnames.HostId = new(go_uuid.UUID)
	*filterHostnames.HostId = ormObj.Id
	if err = db.Where(filterHostnames).Delete(HostnameORM{}).Error; err != nil {
		return nil, err
	}
	filterPorts := PortORM{}
	if ormObj.Id == go_uuid.Nil {
		return nil, errors.EmptyIdError
	}
	filterPorts.HostId = new(go_uuid.UUID)
	*filterPorts.HostId = ormObj.Id
	if err = db.Where(filterPorts).Delete(PortORM{}).Error; err != nil {
		return nil, err
	}
	if err = db.Model(&ormObj).Association("Smurfs").Replace(ormObj.Smurfs).Error; err != nil {
		return nil, err
	}
	ormObj.Smurfs = nil
	filterStatus := StatusORM{}
	if ormObj.Id == go_uuid.Nil {
		return nil, errors.EmptyIdError
	}
	filterStatus.HostId = new(go_uuid.UUID)
	*filterStatus.HostId = ormObj.Id
	if err = db.Where(filterStatus).Delete(StatusORM{}).Error; err != nil {
		return nil, err
	}
	filterUsers := UserORM{}
	if ormObj.Id == go_uuid.Nil {
		return nil, errors.EmptyIdError
	}
	filterUsers.HostId = new(go_uuid.UUID)
	*filterUsers.HostId = ormObj.Id
	if err = db.Where(filterUsers).Delete(UserORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type HostORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchHost executes a basic gorm update call with patch behavior
func DefaultPatchHost(ctx context.Context, in *Host, updateMask *field_mask.FieldMask, db *gorm.DB) (*Host, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Host
	var err error
	if hook, ok := interface{}(&pbObj).(HostWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadHost(ctx, &Host{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(HostWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskHost(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(HostWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateHost(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(HostWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type HostWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Host, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type HostWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Host, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type HostWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Host, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type HostWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Host, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetHost executes a bulk gorm update call with patch behavior
func DefaultPatchSetHost(ctx context.Context, objects []*Host, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Host, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Host, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchHost(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskHost patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskHost(ctx context.Context, patchee *Host, patcher *Host, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Host, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedOS bool
	var updatedStatus bool
	var updatedDistance bool
	var updatedIPIDSequence bool
	var updatedTCPSequence bool
	var updatedTCPTSSequence bool
	var updatedICMPResponse bool
	var updatedTimes bool
	var updatedTrace bool
	var updatedUptime bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"MAC" {
			patchee.MAC = patcher.MAC
			continue
		}
		if f == prefix+"Comm" {
			patchee.Comm = patcher.Comm
			continue
		}
		if f == prefix+"OSName" {
			patchee.OSName = patcher.OSName
			continue
		}
		if f == prefix+"OSFlavor" {
			patchee.OSFlavor = patcher.OSFlavor
			continue
		}
		if f == prefix+"OSSp" {
			patchee.OSSp = patcher.OSSp
			continue
		}
		if f == prefix+"OSLang" {
			patchee.OSLang = patcher.OSLang
			continue
		}
		if f == prefix+"OSFamily" {
			patchee.OSFamily = patcher.OSFamily
			continue
		}
		if f == prefix+"Arch" {
			patchee.Arch = patcher.Arch
			continue
		}
		if f == prefix+"Purpose" {
			patchee.Purpose = patcher.Purpose
			continue
		}
		if f == prefix+"Info" {
			patchee.Info = patcher.Info
			continue
		}
		if f == prefix+"Scope" {
			patchee.Scope = patcher.Scope
			continue
		}
		if f == prefix+"VirtualHost" {
			patchee.VirtualHost = patcher.VirtualHost
			continue
		}
		if f == prefix+"Users" {
			patchee.Users = patcher.Users
			continue
		}
		if f == prefix+"Addresses" {
			patchee.Addresses = patcher.Addresses
			continue
		}
		if !updatedOS && strings.HasPrefix(f, prefix+"OS.") {
			if patcher.OS == nil {
				patchee.OS = nil
				continue
			}
			if patchee.OS == nil {
				patchee.OS = &OS{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"OS."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.OS, patchee.OS, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"OS" {
			updatedOS = true
			patchee.OS = patcher.OS
			continue
		}
		if !updatedStatus && strings.HasPrefix(f, prefix+"Status.") {
			updatedStatus = true
			if patcher.Status == nil {
				patchee.Status = nil
				continue
			}
			if patchee.Status == nil {
				patchee.Status = &Status{}
			}
			if o, err := DefaultApplyFieldMaskStatus(ctx, patchee.Status, patcher.Status, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Status.", db); err != nil {
				return nil, err
			} else {
				patchee.Status = o
			}
			continue
		}
		if f == prefix+"Status" {
			updatedStatus = true
			patchee.Status = patcher.Status
			continue
		}
		if !updatedDistance && strings.HasPrefix(f, prefix+"Distance.") {
			updatedDistance = true
			if patcher.Distance == nil {
				patchee.Distance = nil
				continue
			}
			if patchee.Distance == nil {
				patchee.Distance = &network.Distance{}
			}
			if o, err := network.DefaultApplyFieldMaskDistance(ctx, patchee.Distance, patcher.Distance, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Distance.", db); err != nil {
				return nil, err
			} else {
				patchee.Distance = o
			}
			continue
		}
		if f == prefix+"Distance" {
			updatedDistance = true
			patchee.Distance = patcher.Distance
			continue
		}
		if f == prefix+"StartTime" {
			patchee.StartTime = patcher.StartTime
			continue
		}
		if f == prefix+"EndTime" {
			patchee.EndTime = patcher.EndTime
			continue
		}
		if !updatedIPIDSequence && strings.HasPrefix(f, prefix+"IPIDSequence.") {
			updatedIPIDSequence = true
			if patcher.IPIDSequence == nil {
				patchee.IPIDSequence = nil
				continue
			}
			if patchee.IPIDSequence == nil {
				patchee.IPIDSequence = &network.IPIDSequence{}
			}
			if o, err := network.DefaultApplyFieldMaskIPIDSequence(ctx, patchee.IPIDSequence, patcher.IPIDSequence, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"IPIDSequence.", db); err != nil {
				return nil, err
			} else {
				patchee.IPIDSequence = o
			}
			continue
		}
		if f == prefix+"IPIDSequence" {
			updatedIPIDSequence = true
			patchee.IPIDSequence = patcher.IPIDSequence
			continue
		}
		if !updatedTCPSequence && strings.HasPrefix(f, prefix+"TCPSequence.") {
			updatedTCPSequence = true
			if patcher.TCPSequence == nil {
				patchee.TCPSequence = nil
				continue
			}
			if patchee.TCPSequence == nil {
				patchee.TCPSequence = &network.TCPSequence{}
			}
			if o, err := network.DefaultApplyFieldMaskTCPSequence(ctx, patchee.TCPSequence, patcher.TCPSequence, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"TCPSequence.", db); err != nil {
				return nil, err
			} else {
				patchee.TCPSequence = o
			}
			continue
		}
		if f == prefix+"TCPSequence" {
			updatedTCPSequence = true
			patchee.TCPSequence = patcher.TCPSequence
			continue
		}
		if !updatedTCPTSSequence && strings.HasPrefix(f, prefix+"TCPTSSequence.") {
			updatedTCPTSSequence = true
			if patcher.TCPTSSequence == nil {
				patchee.TCPTSSequence = nil
				continue
			}
			if patchee.TCPTSSequence == nil {
				patchee.TCPTSSequence = &network.TCPTSSequence{}
			}
			if o, err := network.DefaultApplyFieldMaskTCPTSSequence(ctx, patchee.TCPTSSequence, patcher.TCPTSSequence, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"TCPTSSequence.", db); err != nil {
				return nil, err
			} else {
				patchee.TCPTSSequence = o
			}
			continue
		}
		if f == prefix+"TCPTSSequence" {
			updatedTCPTSSequence = true
			patchee.TCPTSSequence = patcher.TCPTSSequence
			continue
		}
		if !updatedICMPResponse && strings.HasPrefix(f, prefix+"ICMPResponse.") {
			if patcher.ICMPResponse == nil {
				patchee.ICMPResponse = nil
				continue
			}
			if patchee.ICMPResponse == nil {
				patchee.ICMPResponse = &network.ICMPResponse{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ICMPResponse."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ICMPResponse, patchee.ICMPResponse, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ICMPResponse" {
			updatedICMPResponse = true
			patchee.ICMPResponse = patcher.ICMPResponse
			continue
		}
		if !updatedTimes && strings.HasPrefix(f, prefix+"Times.") {
			updatedTimes = true
			if patcher.Times == nil {
				patchee.Times = nil
				continue
			}
			if patchee.Times == nil {
				patchee.Times = &network.Times{}
			}
			if o, err := network.DefaultApplyFieldMaskTimes(ctx, patchee.Times, patcher.Times, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Times.", db); err != nil {
				return nil, err
			} else {
				patchee.Times = o
			}
			continue
		}
		if f == prefix+"Times" {
			updatedTimes = true
			patchee.Times = patcher.Times
			continue
		}
		if !updatedTrace && strings.HasPrefix(f, prefix+"Trace.") {
			updatedTrace = true
			if patcher.Trace == nil {
				patchee.Trace = nil
				continue
			}
			if patchee.Trace == nil {
				patchee.Trace = &network.Trace{}
			}
			if o, err := network.DefaultApplyFieldMaskTrace(ctx, patchee.Trace, patcher.Trace, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Trace.", db); err != nil {
				return nil, err
			} else {
				patchee.Trace = o
			}
			continue
		}
		if f == prefix+"Trace" {
			updatedTrace = true
			patchee.Trace = patcher.Trace
			continue
		}
		if !updatedUptime && strings.HasPrefix(f, prefix+"Uptime.") {
			if patcher.Uptime == nil {
				patchee.Uptime = nil
				continue
			}
			if patchee.Uptime == nil {
				patchee.Uptime = &Uptime{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"Uptime."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.Uptime, patchee.Uptime, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"Uptime" {
			updatedUptime = true
			patchee.Uptime = patcher.Uptime
			continue
		}
		if f == prefix+"Comment" {
			patchee.Comment = patcher.Comment
			continue
		}
		if f == prefix+"HostScripts" {
			patchee.HostScripts = patcher.HostScripts
			continue
		}
		if f == prefix+"Smurfs" {
			patchee.Smurfs = patcher.Smurfs
			continue
		}
		if f == prefix+"Hostnames" {
			patchee.Hostnames = patcher.Hostnames
			continue
		}
		if f == prefix+"Ports" {
			patchee.Ports = patcher.Ports
			continue
		}
		if f == prefix+"ExtraPorts" {
			patchee.ExtraPorts = patcher.ExtraPorts
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListHost executes a gorm list call
func DefaultListHost(ctx context.Context, db *gorm.DB) ([]*Host, error) {
	in := Host{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &HostORM{}, &Host{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []HostORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Host{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type HostORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]HostORM) error
}

// DefaultCreateHostname executes a basic gorm create call
func DefaultCreateHostname(ctx context.Context, in *Hostname, db *gorm.DB) (*Hostname, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostnameORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostnameORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type HostnameORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostnameORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadHostname(ctx context.Context, in *Hostname, db *gorm.DB) (*Hostname, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == go_uuid.Nil {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(HostnameORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &HostnameORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostnameORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := HostnameORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(HostnameORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type HostnameORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostnameORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostnameORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteHostname(ctx context.Context, in *Hostname, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == go_uuid.Nil {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(HostnameORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&HostnameORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(HostnameORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type HostnameORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostnameORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteHostnameSet(ctx context.Context, in []*Hostname, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []go_uuid.UUID{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == go_uuid.Nil {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&HostnameORM{})).(HostnameORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&HostnameORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&HostnameORM{})).(HostnameORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type HostnameORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Hostname, *gorm.DB) (*gorm.DB, error)
}
type HostnameORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Hostname, *gorm.DB) error
}

// DefaultStrictUpdateHostname clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateHostname(ctx context.Context, in *Hostname, db *gorm.DB) (*Hostname, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateHostname")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &HostnameORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(HostnameORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(HostnameORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostnameORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type HostnameORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostnameORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostnameORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchHostname executes a basic gorm update call with patch behavior
func DefaultPatchHostname(ctx context.Context, in *Hostname, updateMask *field_mask.FieldMask, db *gorm.DB) (*Hostname, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Hostname
	var err error
	if hook, ok := interface{}(&pbObj).(HostnameWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadHostname(ctx, &Hostname{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(HostnameWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskHostname(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(HostnameWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateHostname(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(HostnameWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type HostnameWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Hostname, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type HostnameWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Hostname, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type HostnameWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Hostname, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type HostnameWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Hostname, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetHostname executes a bulk gorm update call with patch behavior
func DefaultPatchSetHostname(ctx context.Context, objects []*Hostname, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Hostname, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Hostname, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchHostname(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskHostname patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskHostname(ctx context.Context, patchee *Hostname, patcher *Hostname, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Hostname, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListHostname executes a gorm list call
func DefaultListHostname(ctx context.Context, db *gorm.DB) ([]*Hostname, error) {
	in := Hostname{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostnameORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &HostnameORM{}, &Hostname{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostnameORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []HostnameORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostnameORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Hostname{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type HostnameORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostnameORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostnameORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]HostnameORM) error
}

// DefaultCreateStatus executes a basic gorm create call
func DefaultCreateStatus(ctx context.Context, in *Status, db *gorm.DB) (*Status, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StatusORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StatusORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type StatusORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StatusORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

// DefaultApplyFieldMaskStatus patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskStatus(ctx context.Context, patchee *Status, patcher *Status, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Status, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"State" {
			patchee.State = patcher.State
			continue
		}
		if f == prefix+"Reason" {
			patchee.Reason = patcher.Reason
			continue
		}
		if f == prefix+"ReasonTTL" {
			patchee.ReasonTTL = patcher.ReasonTTL
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListStatus executes a gorm list call
func DefaultListStatus(ctx context.Context, db *gorm.DB) ([]*Status, error) {
	in := Status{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StatusORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &StatusORM{}, &Status{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StatusORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []StatusORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StatusORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Status{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type StatusORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StatusORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StatusORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]StatusORM) error
}
