package host

import (
	context "context"
	fmt "fmt"
	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	gorm "github.com/jinzhu/gorm"
	network "github.com/maxlandon/aims/proto/network"
	nmap "github.com/maxlandon/aims/proto/scan/nmap"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	strings "strings"
	time "time"
)

type HostORM struct {
	Addresses       []*network.AddressORM `gorm:"foreignkey:Id;association_foreignkey:Id;many2many:host_addresses;jointable_foreignkey:HostId;association_jointable_foreignkey:AddressId"`
	Arch            string
	Comm            string
	Comment         string
	CreatedAt       *time.Time
	Distance        *network.DistanceORM `gorm:"foreignkey:DistanceId;association_foreignkey:Id"`
	DistanceId      *string
	EndTime         int64
	ExtraPorts      []*ExtraPortORM          `gorm:"foreignkey:HostId;association_foreignkey:Id"`
	HostScripts     []*nmap.ScriptORM        `gorm:"foreignkey:Id;association_foreignkey:Id;many2many:host_scripts;jointable_foreignkey:HostId;association_jointable_foreignkey:ScriptId"`
	Hostnames       []*HostnameORM           `gorm:"foreignkey:HostId;association_foreignkey:Id"`
	ICMPResponse    *network.ICMPResponseORM `gorm:"foreignkey:ICMPResponseId;association_foreignkey:Id"`
	ICMPResponseId  *string
	IPIDSequence    *network.IPIDSequenceORM `gorm:"foreignkey:IPIDSequenceId;association_foreignkey:Id"`
	IPIDSequenceId  *string
	Id              string `gorm:"type:uuid;primary_key"`
	Info            string
	MAC             string
	OS              *OSORM `gorm:"foreignkey:OSId;association_foreignkey:Id"`
	OSFamily        string
	OSFlavor        string
	OSId            *string
	OSLang          string
	OSName          string
	OSSp            string
	Ports           []*PortORM `gorm:"foreignkey:HostId;association_foreignkey:Id"`
	Purpose         string
	Scope           string
	Smurfs          []*nmap.SmurfORM `gorm:"foreignkey:Id;association_foreignkey:Id;many2many:host_smurves;jointable_foreignkey:HostId;association_jointable_foreignkey:SmurfId"`
	StartTime       int64
	Status          *StatusORM              `gorm:"foreignkey:HostId;association_foreignkey:Id"`
	TCPSequence     *network.TCPSequenceORM `gorm:"foreignkey:TCPSequenceId;association_foreignkey:Id"`
	TCPSequenceId   *string
	TCPTSSequence   *network.TCPTSSequenceORM `gorm:"foreignkey:TCPTSSequenceId;association_foreignkey:Id"`
	TCPTSSequenceId *string
	Testing         *network.TimesORM `gorm:"foreignkey:TimesId;association_foreignkey:Id"`
	TimesId         *string
	Trace           *network.TraceORM `gorm:"foreignkey:TraceId;association_foreignkey:Id"`
	TraceId         *string
	UpdatedAt       *time.Time
	Uptime          *UptimeORM `gorm:"foreignkey:UptimeId;association_foreignkey:Id"`
	UptimeId        *string
	Users           []*UserORM `gorm:"foreignkey:HostId;association_foreignkey:Id"`
	VirtualHost     string
}

// TableName overrides the default tablename generated by GORM
func (HostORM) TableName() string {
	return "hosts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Host) ToORM(ctx context.Context) (HostORM, error) {
	to := HostORM{}
	var err error
	if prehook, ok := interface{}(m).(HostWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	to.MAC = m.MAC
	to.Comm = m.Comm
	to.OSName = m.OSName
	to.OSFlavor = m.OSFlavor
	to.OSSp = m.OSSp
	to.OSLang = m.OSLang
	to.OSFamily = m.OSFamily
	to.Arch = m.Arch
	to.Purpose = m.Purpose
	to.Info = m.Info
	to.Scope = m.Scope
	to.VirtualHost = m.VirtualHost
	for _, v := range m.Users {
		if v != nil {
			if tempUsers, cErr := v.ToORM(ctx); cErr == nil {
				to.Users = append(to.Users, &tempUsers)
			} else {
				return to, cErr
			}
		} else {
			to.Users = append(to.Users, nil)
		}
	}
	for _, v := range m.Addresses {
		if v != nil {
			if tempAddresses, cErr := v.ToORM(ctx); cErr == nil {
				to.Addresses = append(to.Addresses, &tempAddresses)
			} else {
				return to, cErr
			}
		} else {
			to.Addresses = append(to.Addresses, nil)
		}
	}
	if m.OS != nil {
		tempOS, err := m.OS.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.OS = &tempOS
	}
	if m.Status != nil {
		tempStatus, err := m.Status.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Status = &tempStatus
	}
	if m.Distance != nil {
		tempDistance, err := m.Distance.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Distance = &tempDistance
	}
	to.StartTime = m.StartTime
	to.EndTime = m.EndTime
	if m.IPIDSequence != nil {
		tempIPIDSequence, err := m.IPIDSequence.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.IPIDSequence = &tempIPIDSequence
	}
	if m.TCPSequence != nil {
		tempTCPSequence, err := m.TCPSequence.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.TCPSequence = &tempTCPSequence
	}
	if m.TCPTSSequence != nil {
		tempTCPTSSequence, err := m.TCPTSSequence.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.TCPTSSequence = &tempTCPTSSequence
	}
	if m.ICMPResponse != nil {
		tempICMPResponse, err := m.ICMPResponse.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.ICMPResponse = &tempICMPResponse
	}
	if m.Testing != nil {
		tempTesting, err := m.Testing.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Testing = &tempTesting
	}
	if m.Trace != nil {
		tempTrace, err := m.Trace.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Trace = &tempTrace
	}
	if m.Uptime != nil {
		tempUptime, err := m.Uptime.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Uptime = &tempUptime
	}
	to.Comment = m.Comment
	for _, v := range m.HostScripts {
		if v != nil {
			if tempHostScripts, cErr := v.ToORM(ctx); cErr == nil {
				to.HostScripts = append(to.HostScripts, &tempHostScripts)
			} else {
				return to, cErr
			}
		} else {
			to.HostScripts = append(to.HostScripts, nil)
		}
	}
	for _, v := range m.Smurfs {
		if v != nil {
			if tempSmurfs, cErr := v.ToORM(ctx); cErr == nil {
				to.Smurfs = append(to.Smurfs, &tempSmurfs)
			} else {
				return to, cErr
			}
		} else {
			to.Smurfs = append(to.Smurfs, nil)
		}
	}
	for _, v := range m.Hostnames {
		if v != nil {
			if tempHostnames, cErr := v.ToORM(ctx); cErr == nil {
				to.Hostnames = append(to.Hostnames, &tempHostnames)
			} else {
				return to, cErr
			}
		} else {
			to.Hostnames = append(to.Hostnames, nil)
		}
	}
	for _, v := range m.Ports {
		if v != nil {
			if tempPorts, cErr := v.ToORM(ctx); cErr == nil {
				to.Ports = append(to.Ports, &tempPorts)
			} else {
				return to, cErr
			}
		} else {
			to.Ports = append(to.Ports, nil)
		}
	}
	for _, v := range m.ExtraPorts {
		if v != nil {
			if tempExtraPorts, cErr := v.ToORM(ctx); cErr == nil {
				to.ExtraPorts = append(to.ExtraPorts, &tempExtraPorts)
			} else {
				return to, cErr
			}
		} else {
			to.ExtraPorts = append(to.ExtraPorts, nil)
		}
	}
	if posthook, ok := interface{}(m).(HostWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *HostORM) ToPB(ctx context.Context) (Host, error) {
	to := Host{}
	var err error
	if prehook, ok := interface{}(m).(HostWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	to.MAC = m.MAC
	to.Comm = m.Comm
	to.OSName = m.OSName
	to.OSFlavor = m.OSFlavor
	to.OSSp = m.OSSp
	to.OSLang = m.OSLang
	to.OSFamily = m.OSFamily
	to.Arch = m.Arch
	to.Purpose = m.Purpose
	to.Info = m.Info
	to.Scope = m.Scope
	to.VirtualHost = m.VirtualHost
	for _, v := range m.Users {
		if v != nil {
			if tempUsers, cErr := v.ToPB(ctx); cErr == nil {
				to.Users = append(to.Users, &tempUsers)
			} else {
				return to, cErr
			}
		} else {
			to.Users = append(to.Users, nil)
		}
	}
	for _, v := range m.Addresses {
		if v != nil {
			if tempAddresses, cErr := v.ToPB(ctx); cErr == nil {
				to.Addresses = append(to.Addresses, &tempAddresses)
			} else {
				return to, cErr
			}
		} else {
			to.Addresses = append(to.Addresses, nil)
		}
	}
	if m.OS != nil {
		tempOS, err := m.OS.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.OS = &tempOS
	}
	if m.Status != nil {
		tempStatus, err := m.Status.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Status = &tempStatus
	}
	if m.Distance != nil {
		tempDistance, err := m.Distance.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Distance = &tempDistance
	}
	to.StartTime = m.StartTime
	to.EndTime = m.EndTime
	if m.IPIDSequence != nil {
		tempIPIDSequence, err := m.IPIDSequence.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.IPIDSequence = &tempIPIDSequence
	}
	if m.TCPSequence != nil {
		tempTCPSequence, err := m.TCPSequence.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.TCPSequence = &tempTCPSequence
	}
	if m.TCPTSSequence != nil {
		tempTCPTSSequence, err := m.TCPTSSequence.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.TCPTSSequence = &tempTCPTSSequence
	}
	if m.ICMPResponse != nil {
		tempICMPResponse, err := m.ICMPResponse.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.ICMPResponse = &tempICMPResponse
	}
	if m.Testing != nil {
		tempTesting, err := m.Testing.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Testing = &tempTesting
	}
	if m.Trace != nil {
		tempTrace, err := m.Trace.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Trace = &tempTrace
	}
	if m.Uptime != nil {
		tempUptime, err := m.Uptime.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Uptime = &tempUptime
	}
	to.Comment = m.Comment
	for _, v := range m.HostScripts {
		if v != nil {
			if tempHostScripts, cErr := v.ToPB(ctx); cErr == nil {
				to.HostScripts = append(to.HostScripts, &tempHostScripts)
			} else {
				return to, cErr
			}
		} else {
			to.HostScripts = append(to.HostScripts, nil)
		}
	}
	for _, v := range m.Smurfs {
		if v != nil {
			if tempSmurfs, cErr := v.ToPB(ctx); cErr == nil {
				to.Smurfs = append(to.Smurfs, &tempSmurfs)
			} else {
				return to, cErr
			}
		} else {
			to.Smurfs = append(to.Smurfs, nil)
		}
	}
	for _, v := range m.Hostnames {
		if v != nil {
			if tempHostnames, cErr := v.ToPB(ctx); cErr == nil {
				to.Hostnames = append(to.Hostnames, &tempHostnames)
			} else {
				return to, cErr
			}
		} else {
			to.Hostnames = append(to.Hostnames, nil)
		}
	}
	for _, v := range m.Ports {
		if v != nil {
			if tempPorts, cErr := v.ToPB(ctx); cErr == nil {
				to.Ports = append(to.Ports, &tempPorts)
			} else {
				return to, cErr
			}
		} else {
			to.Ports = append(to.Ports, nil)
		}
	}
	for _, v := range m.ExtraPorts {
		if v != nil {
			if tempExtraPorts, cErr := v.ToPB(ctx); cErr == nil {
				to.ExtraPorts = append(to.ExtraPorts, &tempExtraPorts)
			} else {
				return to, cErr
			}
		} else {
			to.ExtraPorts = append(to.ExtraPorts, nil)
		}
	}
	if posthook, ok := interface{}(m).(HostWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Host the arg will be the target, the caller the one being converted from

// HostBeforeToORM called before default ToORM code
type HostWithBeforeToORM interface {
	BeforeToORM(context.Context, *HostORM) error
}

// HostAfterToORM called after default ToORM code
type HostWithAfterToORM interface {
	AfterToORM(context.Context, *HostORM) error
}

// HostBeforeToPB called before default ToPB code
type HostWithBeforeToPB interface {
	BeforeToPB(context.Context, *Host) error
}

// HostAfterToPB called after default ToPB code
type HostWithAfterToPB interface {
	AfterToPB(context.Context, *Host) error
}

type HostnameORM struct {
	CreatedAt *time.Time
	HostId    *string
	Id        string `gorm:"type:uuid;primary_key"`
	Name      string
	Type      string
	UpdatedAt *time.Time
}

// TableName overrides the default tablename generated by GORM
func (HostnameORM) TableName() string {
	return "hostnames"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Hostname) ToORM(ctx context.Context) (HostnameORM, error) {
	to := HostnameORM{}
	var err error
	if prehook, ok := interface{}(m).(HostnameWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	to.Name = m.Name
	to.Type = m.Type
	if posthook, ok := interface{}(m).(HostnameWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *HostnameORM) ToPB(ctx context.Context) (Hostname, error) {
	to := Hostname{}
	var err error
	if prehook, ok := interface{}(m).(HostnameWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	to.Name = m.Name
	to.Type = m.Type
	if posthook, ok := interface{}(m).(HostnameWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Hostname the arg will be the target, the caller the one being converted from

// HostnameBeforeToORM called before default ToORM code
type HostnameWithBeforeToORM interface {
	BeforeToORM(context.Context, *HostnameORM) error
}

// HostnameAfterToORM called after default ToORM code
type HostnameWithAfterToORM interface {
	AfterToORM(context.Context, *HostnameORM) error
}

// HostnameBeforeToPB called before default ToPB code
type HostnameWithBeforeToPB interface {
	BeforeToPB(context.Context, *Hostname) error
}

// HostnameAfterToPB called after default ToPB code
type HostnameWithAfterToPB interface {
	AfterToPB(context.Context, *Hostname) error
}

type UptimeORM struct {
	Id       string `gorm:"type:uuid;primary_key"`
	LastBoot string
	Seconds  int32
}

// TableName overrides the default tablename generated by GORM
func (UptimeORM) TableName() string {
	return "uptimes"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Uptime) ToORM(ctx context.Context) (UptimeORM, error) {
	to := UptimeORM{}
	var err error
	if prehook, ok := interface{}(m).(UptimeWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Seconds = m.Seconds
	to.LastBoot = m.LastBoot
	if posthook, ok := interface{}(m).(UptimeWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *UptimeORM) ToPB(ctx context.Context) (Uptime, error) {
	to := Uptime{}
	var err error
	if prehook, ok := interface{}(m).(UptimeWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Seconds = m.Seconds
	to.LastBoot = m.LastBoot
	if posthook, ok := interface{}(m).(UptimeWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Uptime the arg will be the target, the caller the one being converted from

// UptimeBeforeToORM called before default ToORM code
type UptimeWithBeforeToORM interface {
	BeforeToORM(context.Context, *UptimeORM) error
}

// UptimeAfterToORM called after default ToORM code
type UptimeWithAfterToORM interface {
	AfterToORM(context.Context, *UptimeORM) error
}

// UptimeBeforeToPB called before default ToPB code
type UptimeWithBeforeToPB interface {
	BeforeToPB(context.Context, *Uptime) error
}

// UptimeAfterToPB called after default ToPB code
type UptimeWithAfterToPB interface {
	AfterToPB(context.Context, *Uptime) error
}

type StatusORM struct {
	HostId    *string
	Id        string `gorm:"type:uuid;primary_key"`
	Reason    string
	ReasonTTL string
	State     string
}

// TableName overrides the default tablename generated by GORM
func (StatusORM) TableName() string {
	return "statuses"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Status) ToORM(ctx context.Context) (StatusORM, error) {
	to := StatusORM{}
	var err error
	if prehook, ok := interface{}(m).(StatusWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.State = m.State
	to.Reason = m.Reason
	to.ReasonTTL = m.ReasonTTL
	if posthook, ok := interface{}(m).(StatusWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *StatusORM) ToPB(ctx context.Context) (Status, error) {
	to := Status{}
	var err error
	if prehook, ok := interface{}(m).(StatusWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.State = m.State
	to.Reason = m.Reason
	to.ReasonTTL = m.ReasonTTL
	if posthook, ok := interface{}(m).(StatusWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Status the arg will be the target, the caller the one being converted from

// StatusBeforeToORM called before default ToORM code
type StatusWithBeforeToORM interface {
	BeforeToORM(context.Context, *StatusORM) error
}

// StatusAfterToORM called after default ToORM code
type StatusWithAfterToORM interface {
	AfterToORM(context.Context, *StatusORM) error
}

// StatusBeforeToPB called before default ToPB code
type StatusWithBeforeToPB interface {
	BeforeToPB(context.Context, *Status) error
}

// StatusAfterToPB called after default ToPB code
type StatusWithAfterToPB interface {
	AfterToPB(context.Context, *Status) error
}

// DefaultCreateHost executes a basic gorm create call
func DefaultCreateHost(ctx context.Context, in *Host, db *gorm.DB) (*Host, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type HostORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadHost(ctx context.Context, in *Host, db *gorm.DB) (*Host, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(HostORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &HostORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := HostORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(HostORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type HostORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteHost(ctx context.Context, in *Host, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(HostORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&HostORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(HostORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type HostORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteHostSet(ctx context.Context, in []*Host, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&HostORM{})).(HostORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&HostORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&HostORM{})).(HostORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type HostORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Host, *gorm.DB) (*gorm.DB, error)
}
type HostORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Host, *gorm.DB) error
}

// DefaultStrictUpdateHost clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateHost(ctx context.Context, in *Host, db *gorm.DB) (*Host, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateHost")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &HostORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(HostORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Model(&ormObj).Association("Addresses").Replace(ormObj.Addresses).Error; err != nil {
		return nil, err
	}
	ormObj.Addresses = nil
	filterExtraPorts := ExtraPortORM{}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	filterExtraPorts.HostId = new(string)
	*filterExtraPorts.HostId = ormObj.Id
	if err = db.Where(filterExtraPorts).Delete(ExtraPortORM{}).Error; err != nil {
		return nil, err
	}
	if err = db.Model(&ormObj).Association("HostScripts").Replace(ormObj.HostScripts).Error; err != nil {
		return nil, err
	}
	ormObj.HostScripts = nil
	filterHostnames := HostnameORM{}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	filterHostnames.HostId = new(string)
	*filterHostnames.HostId = ormObj.Id
	if err = db.Where(filterHostnames).Delete(HostnameORM{}).Error; err != nil {
		return nil, err
	}
	filterPorts := PortORM{}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	filterPorts.HostId = new(string)
	*filterPorts.HostId = ormObj.Id
	if err = db.Where(filterPorts).Delete(PortORM{}).Error; err != nil {
		return nil, err
	}
	if err = db.Model(&ormObj).Association("Smurfs").Replace(ormObj.Smurfs).Error; err != nil {
		return nil, err
	}
	ormObj.Smurfs = nil
	filterStatus := StatusORM{}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	filterStatus.HostId = new(string)
	*filterStatus.HostId = ormObj.Id
	if err = db.Where(filterStatus).Delete(StatusORM{}).Error; err != nil {
		return nil, err
	}
	filterUsers := UserORM{}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	filterUsers.HostId = new(string)
	*filterUsers.HostId = ormObj.Id
	if err = db.Where(filterUsers).Delete(UserORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type HostORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchHost executes a basic gorm update call with patch behavior
func DefaultPatchHost(ctx context.Context, in *Host, updateMask *field_mask.FieldMask, db *gorm.DB) (*Host, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Host
	var err error
	if hook, ok := interface{}(&pbObj).(HostWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadHost(ctx, &Host{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(HostWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskHost(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(HostWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateHost(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(HostWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type HostWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Host, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type HostWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Host, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type HostWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Host, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type HostWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Host, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetHost executes a bulk gorm update call with patch behavior
func DefaultPatchSetHost(ctx context.Context, objects []*Host, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Host, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Host, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchHost(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskHost patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskHost(ctx context.Context, patchee *Host, patcher *Host, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Host, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedOS bool
	var updatedStatus bool
	var updatedDistance bool
	var updatedIPIDSequence bool
	var updatedTCPSequence bool
	var updatedTCPTSSequence bool
	var updatedICMPResponse bool
	var updatedTesting bool
	var updatedTrace bool
	var updatedUptime bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"MAC" {
			patchee.MAC = patcher.MAC
			continue
		}
		if f == prefix+"Comm" {
			patchee.Comm = patcher.Comm
			continue
		}
		if f == prefix+"OSName" {
			patchee.OSName = patcher.OSName
			continue
		}
		if f == prefix+"OSFlavor" {
			patchee.OSFlavor = patcher.OSFlavor
			continue
		}
		if f == prefix+"OSSp" {
			patchee.OSSp = patcher.OSSp
			continue
		}
		if f == prefix+"OSLang" {
			patchee.OSLang = patcher.OSLang
			continue
		}
		if f == prefix+"OSFamily" {
			patchee.OSFamily = patcher.OSFamily
			continue
		}
		if f == prefix+"Arch" {
			patchee.Arch = patcher.Arch
			continue
		}
		if f == prefix+"Purpose" {
			patchee.Purpose = patcher.Purpose
			continue
		}
		if f == prefix+"Info" {
			patchee.Info = patcher.Info
			continue
		}
		if f == prefix+"Scope" {
			patchee.Scope = patcher.Scope
			continue
		}
		if f == prefix+"VirtualHost" {
			patchee.VirtualHost = patcher.VirtualHost
			continue
		}
		if f == prefix+"Users" {
			patchee.Users = patcher.Users
			continue
		}
		if f == prefix+"Addresses" {
			patchee.Addresses = patcher.Addresses
			continue
		}
		if !updatedOS && strings.HasPrefix(f, prefix+"OS.") {
			updatedOS = true
			if patcher.OS == nil {
				patchee.OS = nil
				continue
			}
			if patchee.OS == nil {
				patchee.OS = &OS{}
			}
			if o, err := DefaultApplyFieldMaskOS(ctx, patchee.OS, patcher.OS, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"OS.", db); err != nil {
				return nil, err
			} else {
				patchee.OS = o
			}
			continue
		}
		if f == prefix+"OS" {
			updatedOS = true
			patchee.OS = patcher.OS
			continue
		}
		if !updatedStatus && strings.HasPrefix(f, prefix+"Status.") {
			updatedStatus = true
			if patcher.Status == nil {
				patchee.Status = nil
				continue
			}
			if patchee.Status == nil {
				patchee.Status = &Status{}
			}
			if o, err := DefaultApplyFieldMaskStatus(ctx, patchee.Status, patcher.Status, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Status.", db); err != nil {
				return nil, err
			} else {
				patchee.Status = o
			}
			continue
		}
		if f == prefix+"Status" {
			updatedStatus = true
			patchee.Status = patcher.Status
			continue
		}
		if !updatedDistance && strings.HasPrefix(f, prefix+"Distance.") {
			updatedDistance = true
			if patcher.Distance == nil {
				patchee.Distance = nil
				continue
			}
			if patchee.Distance == nil {
				patchee.Distance = &network.Distance{}
			}
			if o, err := network.DefaultApplyFieldMaskDistance(ctx, patchee.Distance, patcher.Distance, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Distance.", db); err != nil {
				return nil, err
			} else {
				patchee.Distance = o
			}
			continue
		}
		if f == prefix+"Distance" {
			updatedDistance = true
			patchee.Distance = patcher.Distance
			continue
		}
		if f == prefix+"StartTime" {
			patchee.StartTime = patcher.StartTime
			continue
		}
		if f == prefix+"EndTime" {
			patchee.EndTime = patcher.EndTime
			continue
		}
		if !updatedIPIDSequence && strings.HasPrefix(f, prefix+"IPIDSequence.") {
			updatedIPIDSequence = true
			if patcher.IPIDSequence == nil {
				patchee.IPIDSequence = nil
				continue
			}
			if patchee.IPIDSequence == nil {
				patchee.IPIDSequence = &network.IPIDSequence{}
			}
			if o, err := network.DefaultApplyFieldMaskIPIDSequence(ctx, patchee.IPIDSequence, patcher.IPIDSequence, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"IPIDSequence.", db); err != nil {
				return nil, err
			} else {
				patchee.IPIDSequence = o
			}
			continue
		}
		if f == prefix+"IPIDSequence" {
			updatedIPIDSequence = true
			patchee.IPIDSequence = patcher.IPIDSequence
			continue
		}
		if !updatedTCPSequence && strings.HasPrefix(f, prefix+"TCPSequence.") {
			updatedTCPSequence = true
			if patcher.TCPSequence == nil {
				patchee.TCPSequence = nil
				continue
			}
			if patchee.TCPSequence == nil {
				patchee.TCPSequence = &network.TCPSequence{}
			}
			if o, err := network.DefaultApplyFieldMaskTCPSequence(ctx, patchee.TCPSequence, patcher.TCPSequence, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"TCPSequence.", db); err != nil {
				return nil, err
			} else {
				patchee.TCPSequence = o
			}
			continue
		}
		if f == prefix+"TCPSequence" {
			updatedTCPSequence = true
			patchee.TCPSequence = patcher.TCPSequence
			continue
		}
		if !updatedTCPTSSequence && strings.HasPrefix(f, prefix+"TCPTSSequence.") {
			updatedTCPTSSequence = true
			if patcher.TCPTSSequence == nil {
				patchee.TCPTSSequence = nil
				continue
			}
			if patchee.TCPTSSequence == nil {
				patchee.TCPTSSequence = &network.TCPTSSequence{}
			}
			if o, err := network.DefaultApplyFieldMaskTCPTSSequence(ctx, patchee.TCPTSSequence, patcher.TCPTSSequence, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"TCPTSSequence.", db); err != nil {
				return nil, err
			} else {
				patchee.TCPTSSequence = o
			}
			continue
		}
		if f == prefix+"TCPTSSequence" {
			updatedTCPTSSequence = true
			patchee.TCPTSSequence = patcher.TCPTSSequence
			continue
		}
		if !updatedICMPResponse && strings.HasPrefix(f, prefix+"ICMPResponse.") {
			updatedICMPResponse = true
			if patcher.ICMPResponse == nil {
				patchee.ICMPResponse = nil
				continue
			}
			if patchee.ICMPResponse == nil {
				patchee.ICMPResponse = &network.ICMPResponse{}
			}
			if o, err := network.DefaultApplyFieldMaskICMPResponse(ctx, patchee.ICMPResponse, patcher.ICMPResponse, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"ICMPResponse.", db); err != nil {
				return nil, err
			} else {
				patchee.ICMPResponse = o
			}
			continue
		}
		if f == prefix+"ICMPResponse" {
			updatedICMPResponse = true
			patchee.ICMPResponse = patcher.ICMPResponse
			continue
		}
		if !updatedTesting && strings.HasPrefix(f, prefix+"Testing.") {
			updatedTesting = true
			if patcher.Testing == nil {
				patchee.Testing = nil
				continue
			}
			if patchee.Testing == nil {
				patchee.Testing = &network.Times{}
			}
			if o, err := network.DefaultApplyFieldMaskTimes(ctx, patchee.Testing, patcher.Testing, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Testing.", db); err != nil {
				return nil, err
			} else {
				patchee.Testing = o
			}
			continue
		}
		if f == prefix+"Testing" {
			updatedTesting = true
			patchee.Testing = patcher.Testing
			continue
		}
		if !updatedTrace && strings.HasPrefix(f, prefix+"Trace.") {
			updatedTrace = true
			if patcher.Trace == nil {
				patchee.Trace = nil
				continue
			}
			if patchee.Trace == nil {
				patchee.Trace = &network.Trace{}
			}
			if o, err := network.DefaultApplyFieldMaskTrace(ctx, patchee.Trace, patcher.Trace, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Trace.", db); err != nil {
				return nil, err
			} else {
				patchee.Trace = o
			}
			continue
		}
		if f == prefix+"Trace" {
			updatedTrace = true
			patchee.Trace = patcher.Trace
			continue
		}
		if !updatedUptime && strings.HasPrefix(f, prefix+"Uptime.") {
			updatedUptime = true
			if patcher.Uptime == nil {
				patchee.Uptime = nil
				continue
			}
			if patchee.Uptime == nil {
				patchee.Uptime = &Uptime{}
			}
			if o, err := DefaultApplyFieldMaskUptime(ctx, patchee.Uptime, patcher.Uptime, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Uptime.", db); err != nil {
				return nil, err
			} else {
				patchee.Uptime = o
			}
			continue
		}
		if f == prefix+"Uptime" {
			updatedUptime = true
			patchee.Uptime = patcher.Uptime
			continue
		}
		if f == prefix+"Comment" {
			patchee.Comment = patcher.Comment
			continue
		}
		if f == prefix+"HostScripts" {
			patchee.HostScripts = patcher.HostScripts
			continue
		}
		if f == prefix+"Smurfs" {
			patchee.Smurfs = patcher.Smurfs
			continue
		}
		if f == prefix+"Hostnames" {
			patchee.Hostnames = patcher.Hostnames
			continue
		}
		if f == prefix+"Ports" {
			patchee.Ports = patcher.Ports
			continue
		}
		if f == prefix+"ExtraPorts" {
			patchee.ExtraPorts = patcher.ExtraPorts
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListHost executes a gorm list call
func DefaultListHost(ctx context.Context, db *gorm.DB) ([]*Host, error) {
	in := Host{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &HostORM{}, &Host{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []HostORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Host{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type HostORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]HostORM) error
}

// DefaultCreateHostname executes a basic gorm create call
func DefaultCreateHostname(ctx context.Context, in *Hostname, db *gorm.DB) (*Hostname, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostnameORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostnameORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type HostnameORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostnameORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadHostname(ctx context.Context, in *Hostname, db *gorm.DB) (*Hostname, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(HostnameORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &HostnameORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostnameORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := HostnameORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(HostnameORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type HostnameORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostnameORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostnameORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteHostname(ctx context.Context, in *Hostname, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(HostnameORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&HostnameORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(HostnameORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type HostnameORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostnameORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteHostnameSet(ctx context.Context, in []*Hostname, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&HostnameORM{})).(HostnameORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&HostnameORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&HostnameORM{})).(HostnameORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type HostnameORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Hostname, *gorm.DB) (*gorm.DB, error)
}
type HostnameORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Hostname, *gorm.DB) error
}

// DefaultStrictUpdateHostname clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateHostname(ctx context.Context, in *Hostname, db *gorm.DB) (*Hostname, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateHostname")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &HostnameORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(HostnameORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(HostnameORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostnameORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type HostnameORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostnameORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostnameORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchHostname executes a basic gorm update call with patch behavior
func DefaultPatchHostname(ctx context.Context, in *Hostname, updateMask *field_mask.FieldMask, db *gorm.DB) (*Hostname, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Hostname
	var err error
	if hook, ok := interface{}(&pbObj).(HostnameWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadHostname(ctx, &Hostname{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(HostnameWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskHostname(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(HostnameWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateHostname(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(HostnameWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type HostnameWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Hostname, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type HostnameWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Hostname, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type HostnameWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Hostname, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type HostnameWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Hostname, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetHostname executes a bulk gorm update call with patch behavior
func DefaultPatchSetHostname(ctx context.Context, objects []*Hostname, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Hostname, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Hostname, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchHostname(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskHostname patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskHostname(ctx context.Context, patchee *Hostname, patcher *Hostname, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Hostname, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListHostname executes a gorm list call
func DefaultListHostname(ctx context.Context, db *gorm.DB) ([]*Hostname, error) {
	in := Hostname{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostnameORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &HostnameORM{}, &Hostname{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostnameORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []HostnameORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostnameORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Hostname{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type HostnameORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostnameORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostnameORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]HostnameORM) error
}

// DefaultCreateUptime executes a basic gorm create call
func DefaultCreateUptime(ctx context.Context, in *Uptime, db *gorm.DB) (*Uptime, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UptimeORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UptimeORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type UptimeORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UptimeORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadUptime(ctx context.Context, in *Uptime, db *gorm.DB) (*Uptime, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UptimeORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &UptimeORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UptimeORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := UptimeORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(UptimeORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type UptimeORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UptimeORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UptimeORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteUptime(ctx context.Context, in *Uptime, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UptimeORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&UptimeORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(UptimeORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type UptimeORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UptimeORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteUptimeSet(ctx context.Context, in []*Uptime, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&UptimeORM{})).(UptimeORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&UptimeORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&UptimeORM{})).(UptimeORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type UptimeORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Uptime, *gorm.DB) (*gorm.DB, error)
}
type UptimeORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Uptime, *gorm.DB) error
}

// DefaultStrictUpdateUptime clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateUptime(ctx context.Context, in *Uptime, db *gorm.DB) (*Uptime, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateUptime")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &UptimeORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(UptimeORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(UptimeORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UptimeORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type UptimeORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UptimeORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UptimeORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchUptime executes a basic gorm update call with patch behavior
func DefaultPatchUptime(ctx context.Context, in *Uptime, updateMask *field_mask.FieldMask, db *gorm.DB) (*Uptime, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Uptime
	var err error
	if hook, ok := interface{}(&pbObj).(UptimeWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadUptime(ctx, &Uptime{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(UptimeWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskUptime(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(UptimeWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateUptime(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(UptimeWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type UptimeWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Uptime, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UptimeWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Uptime, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UptimeWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Uptime, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UptimeWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Uptime, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetUptime executes a bulk gorm update call with patch behavior
func DefaultPatchSetUptime(ctx context.Context, objects []*Uptime, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Uptime, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Uptime, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchUptime(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskUptime patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskUptime(ctx context.Context, patchee *Uptime, patcher *Uptime, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Uptime, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Seconds" {
			patchee.Seconds = patcher.Seconds
			continue
		}
		if f == prefix+"LastBoot" {
			patchee.LastBoot = patcher.LastBoot
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListUptime executes a gorm list call
func DefaultListUptime(ctx context.Context, db *gorm.DB) ([]*Uptime, error) {
	in := Uptime{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UptimeORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &UptimeORM{}, &Uptime{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UptimeORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []UptimeORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UptimeORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Uptime{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type UptimeORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UptimeORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UptimeORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]UptimeORM) error
}

// DefaultCreateStatus executes a basic gorm create call
func DefaultCreateStatus(ctx context.Context, in *Status, db *gorm.DB) (*Status, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StatusORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StatusORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type StatusORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StatusORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadStatus(ctx context.Context, in *Status, db *gorm.DB) (*Status, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(StatusORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &StatusORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StatusORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := StatusORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(StatusORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type StatusORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StatusORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StatusORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteStatus(ctx context.Context, in *Status, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(StatusORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&StatusORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(StatusORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type StatusORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StatusORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteStatusSet(ctx context.Context, in []*Status, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&StatusORM{})).(StatusORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&StatusORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&StatusORM{})).(StatusORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type StatusORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Status, *gorm.DB) (*gorm.DB, error)
}
type StatusORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Status, *gorm.DB) error
}

// DefaultStrictUpdateStatus clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateStatus(ctx context.Context, in *Status, db *gorm.DB) (*Status, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateStatus")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &StatusORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(StatusORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(StatusORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StatusORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type StatusORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StatusORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StatusORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchStatus executes a basic gorm update call with patch behavior
func DefaultPatchStatus(ctx context.Context, in *Status, updateMask *field_mask.FieldMask, db *gorm.DB) (*Status, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Status
	var err error
	if hook, ok := interface{}(&pbObj).(StatusWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadStatus(ctx, &Status{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(StatusWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskStatus(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(StatusWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateStatus(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(StatusWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type StatusWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Status, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type StatusWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Status, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type StatusWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Status, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type StatusWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Status, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetStatus executes a bulk gorm update call with patch behavior
func DefaultPatchSetStatus(ctx context.Context, objects []*Status, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Status, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Status, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchStatus(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskStatus patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskStatus(ctx context.Context, patchee *Status, patcher *Status, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Status, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"State" {
			patchee.State = patcher.State
			continue
		}
		if f == prefix+"Reason" {
			patchee.Reason = patcher.Reason
			continue
		}
		if f == prefix+"ReasonTTL" {
			patchee.ReasonTTL = patcher.ReasonTTL
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListStatus executes a gorm list call
func DefaultListStatus(ctx context.Context, db *gorm.DB) ([]*Status, error) {
	in := Status{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StatusORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &StatusORM{}, &Status{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StatusORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []StatusORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StatusORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Status{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type StatusORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StatusORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StatusORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]StatusORM) error
}
