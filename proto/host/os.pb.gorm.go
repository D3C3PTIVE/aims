package host

import (
	context "context"
	fmt "fmt"
	os "github.com/d3c3ptive/aims/proto/host/os"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	gorm "gorm.io/gorm"
)

type OSORM struct {
	Fingerprints []*OSFingerprintORM `gorm:"foreignKey:OSId;references:Id"`
	Id           string              `gorm:"type:uuid;primaryKey"`
	Matches      []*OSMatchORM       `gorm:"foreignKey:OSId;references:Id"`
	PortsUsed    []*PortUsedORM      `gorm:"foreignKey:OSId;references:Id"`
}

// TableName overrides the default tablename generated by GORM
func (OSORM) TableName() string {
	return "os"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *OS) ToORM(ctx context.Context) (OSORM, error) {
	to := OSORM{}
	var err error
	if prehook, ok := interface{}(m).(OSWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	for _, v := range m.PortsUsed {
		if v != nil {
			if tempPortsUsed, cErr := v.ToORM(ctx); cErr == nil {
				to.PortsUsed = append(to.PortsUsed, &tempPortsUsed)
			} else {
				return to, cErr
			}
		} else {
			to.PortsUsed = append(to.PortsUsed, nil)
		}
	}
	for _, v := range m.Matches {
		if v != nil {
			if tempMatches, cErr := v.ToORM(ctx); cErr == nil {
				to.Matches = append(to.Matches, &tempMatches)
			} else {
				return to, cErr
			}
		} else {
			to.Matches = append(to.Matches, nil)
		}
	}
	for _, v := range m.Fingerprints {
		if v != nil {
			if tempFingerprints, cErr := v.ToORM(ctx); cErr == nil {
				to.Fingerprints = append(to.Fingerprints, &tempFingerprints)
			} else {
				return to, cErr
			}
		} else {
			to.Fingerprints = append(to.Fingerprints, nil)
		}
	}
	if posthook, ok := interface{}(m).(OSWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *OSORM) ToPB(ctx context.Context) (OS, error) {
	to := OS{}
	var err error
	if prehook, ok := interface{}(m).(OSWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	for _, v := range m.PortsUsed {
		if v != nil {
			if tempPortsUsed, cErr := v.ToPB(ctx); cErr == nil {
				to.PortsUsed = append(to.PortsUsed, &tempPortsUsed)
			} else {
				return to, cErr
			}
		} else {
			to.PortsUsed = append(to.PortsUsed, nil)
		}
	}
	for _, v := range m.Matches {
		if v != nil {
			if tempMatches, cErr := v.ToPB(ctx); cErr == nil {
				to.Matches = append(to.Matches, &tempMatches)
			} else {
				return to, cErr
			}
		} else {
			to.Matches = append(to.Matches, nil)
		}
	}
	for _, v := range m.Fingerprints {
		if v != nil {
			if tempFingerprints, cErr := v.ToPB(ctx); cErr == nil {
				to.Fingerprints = append(to.Fingerprints, &tempFingerprints)
			} else {
				return to, cErr
			}
		} else {
			to.Fingerprints = append(to.Fingerprints, nil)
		}
	}
	if posthook, ok := interface{}(m).(OSWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type OS the arg will be the target, the caller the one being converted from

// OSBeforeToORM called before default ToORM code
type OSWithBeforeToORM interface {
	BeforeToORM(context.Context, *OSORM) error
}

// OSAfterToORM called after default ToORM code
type OSWithAfterToORM interface {
	AfterToORM(context.Context, *OSORM) error
}

// OSBeforeToPB called before default ToPB code
type OSWithBeforeToPB interface {
	BeforeToPB(context.Context, *OS) error
}

// OSAfterToPB called after default ToPB code
type OSWithAfterToPB interface {
	AfterToPB(context.Context, *OS) error
}

type OSMatchORM struct {
	Accuracy int32
	Classes  []*OSClassORM `gorm:"foreignKey:OSMatchId;references:Id"`
	Id       string        `gorm:"type:uuid;primaryKey"`
	Line     int32
	Name     string
	OSId     *string
}

// TableName overrides the default tablename generated by GORM
func (OSMatchORM) TableName() string {
	return "os_matches"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *OSMatch) ToORM(ctx context.Context) (OSMatchORM, error) {
	to := OSMatchORM{}
	var err error
	if prehook, ok := interface{}(m).(OSMatchWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Accuracy = m.Accuracy
	to.Line = m.Line
	for _, v := range m.Classes {
		if v != nil {
			if tempClasses, cErr := v.ToORM(ctx); cErr == nil {
				to.Classes = append(to.Classes, &tempClasses)
			} else {
				return to, cErr
			}
		} else {
			to.Classes = append(to.Classes, nil)
		}
	}
	if posthook, ok := interface{}(m).(OSMatchWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *OSMatchORM) ToPB(ctx context.Context) (OSMatch, error) {
	to := OSMatch{}
	var err error
	if prehook, ok := interface{}(m).(OSMatchWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Accuracy = m.Accuracy
	to.Line = m.Line
	for _, v := range m.Classes {
		if v != nil {
			if tempClasses, cErr := v.ToPB(ctx); cErr == nil {
				to.Classes = append(to.Classes, &tempClasses)
			} else {
				return to, cErr
			}
		} else {
			to.Classes = append(to.Classes, nil)
		}
	}
	if posthook, ok := interface{}(m).(OSMatchWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type OSMatch the arg will be the target, the caller the one being converted from

// OSMatchBeforeToORM called before default ToORM code
type OSMatchWithBeforeToORM interface {
	BeforeToORM(context.Context, *OSMatchORM) error
}

// OSMatchAfterToORM called after default ToORM code
type OSMatchWithAfterToORM interface {
	AfterToORM(context.Context, *OSMatchORM) error
}

// OSMatchBeforeToPB called before default ToPB code
type OSMatchWithBeforeToPB interface {
	BeforeToPB(context.Context, *OSMatch) error
}

// OSMatchAfterToPB called after default ToPB code
type OSMatchWithAfterToPB interface {
	AfterToPB(context.Context, *OSMatch) error
}

type PortUsedORM struct {
	Id       string `gorm:"type:uuid;primaryKey"`
	Number   uint32
	OSId     *string
	Protocol string
	State    string
}

// TableName overrides the default tablename generated by GORM
func (PortUsedORM) TableName() string {
	return "port_useds"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *PortUsed) ToORM(ctx context.Context) (PortUsedORM, error) {
	to := PortUsedORM{}
	var err error
	if prehook, ok := interface{}(m).(PortUsedWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Number = m.Number
	to.State = m.State
	to.Protocol = m.Protocol
	if posthook, ok := interface{}(m).(PortUsedWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PortUsedORM) ToPB(ctx context.Context) (PortUsed, error) {
	to := PortUsed{}
	var err error
	if prehook, ok := interface{}(m).(PortUsedWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Number = m.Number
	to.State = m.State
	to.Protocol = m.Protocol
	if posthook, ok := interface{}(m).(PortUsedWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type PortUsed the arg will be the target, the caller the one being converted from

// PortUsedBeforeToORM called before default ToORM code
type PortUsedWithBeforeToORM interface {
	BeforeToORM(context.Context, *PortUsedORM) error
}

// PortUsedAfterToORM called after default ToORM code
type PortUsedWithAfterToORM interface {
	AfterToORM(context.Context, *PortUsedORM) error
}

// PortUsedBeforeToPB called before default ToPB code
type PortUsedWithBeforeToPB interface {
	BeforeToPB(context.Context, *PortUsed) error
}

// PortUsedAfterToPB called after default ToPB code
type PortUsedWithAfterToPB interface {
	AfterToPB(context.Context, *PortUsed) error
}

type OSFingerprintORM struct {
	Fingerprint string
	Id          string `gorm:"type:uuid;primaryKey"`
	OSId        *string
}

// TableName overrides the default tablename generated by GORM
func (OSFingerprintORM) TableName() string {
	return "os_fingerprints"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *OSFingerprint) ToORM(ctx context.Context) (OSFingerprintORM, error) {
	to := OSFingerprintORM{}
	var err error
	if prehook, ok := interface{}(m).(OSFingerprintWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Fingerprint = m.Fingerprint
	if posthook, ok := interface{}(m).(OSFingerprintWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *OSFingerprintORM) ToPB(ctx context.Context) (OSFingerprint, error) {
	to := OSFingerprint{}
	var err error
	if prehook, ok := interface{}(m).(OSFingerprintWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Fingerprint = m.Fingerprint
	if posthook, ok := interface{}(m).(OSFingerprintWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type OSFingerprint the arg will be the target, the caller the one being converted from

// OSFingerprintBeforeToORM called before default ToORM code
type OSFingerprintWithBeforeToORM interface {
	BeforeToORM(context.Context, *OSFingerprintORM) error
}

// OSFingerprintAfterToORM called after default ToORM code
type OSFingerprintWithAfterToORM interface {
	AfterToORM(context.Context, *OSFingerprintORM) error
}

// OSFingerprintBeforeToPB called before default ToPB code
type OSFingerprintWithBeforeToPB interface {
	BeforeToPB(context.Context, *OSFingerprint) error
}

// OSFingerprintAfterToPB called after default ToPB code
type OSFingerprintWithAfterToPB interface {
	AfterToPB(context.Context, *OSFingerprint) error
}

type OSClassORM struct {
	Accuracy     int32
	Family       int32
	Id           string `gorm:"type:uuid;primaryKey"`
	OSGeneration string
	OSMatchId    *string
	Type         string
	Vendor       string
}

// TableName overrides the default tablename generated by GORM
func (OSClassORM) TableName() string {
	return "os_classes"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *OSClass) ToORM(ctx context.Context) (OSClassORM, error) {
	to := OSClassORM{}
	var err error
	if prehook, ok := interface{}(m).(OSClassWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Vendor = m.Vendor
	to.OSGeneration = m.OSGeneration
	to.Type = m.Type
	to.Accuracy = m.Accuracy
	to.Family = int32(m.Family)
	// Repeated type string is not an ORMable message type
	if posthook, ok := interface{}(m).(OSClassWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *OSClassORM) ToPB(ctx context.Context) (OSClass, error) {
	to := OSClass{}
	var err error
	if prehook, ok := interface{}(m).(OSClassWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Vendor = m.Vendor
	to.OSGeneration = m.OSGeneration
	to.Type = m.Type
	to.Accuracy = m.Accuracy
	to.Family = os.Family(m.Family)
	// Repeated type string is not an ORMable message type
	if posthook, ok := interface{}(m).(OSClassWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type OSClass the arg will be the target, the caller the one being converted from

// OSClassBeforeToORM called before default ToORM code
type OSClassWithBeforeToORM interface {
	BeforeToORM(context.Context, *OSClassORM) error
}

// OSClassAfterToORM called after default ToORM code
type OSClassWithAfterToORM interface {
	AfterToORM(context.Context, *OSClassORM) error
}

// OSClassBeforeToPB called before default ToPB code
type OSClassWithBeforeToPB interface {
	BeforeToPB(context.Context, *OSClass) error
}

// OSClassAfterToPB called after default ToPB code
type OSClassWithAfterToPB interface {
	AfterToPB(context.Context, *OSClass) error
}

// DefaultCreateOS executes a basic gorm create call
func DefaultCreateOS(ctx context.Context, in *OS, db *gorm.DB) (*OS, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(OSORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(OSORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type OSORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OSORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadOS(ctx context.Context, in *OS, db *gorm.DB) (*OS, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(OSORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(OSORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := OSORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(OSORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type OSORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OSORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OSORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteOS(ctx context.Context, in *OS, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(OSORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&OSORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(OSORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type OSORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OSORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteOSSet(ctx context.Context, in []*OS, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&OSORM{})).(OSORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&OSORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&OSORM{})).(OSORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type OSORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*OS, *gorm.DB) (*gorm.DB, error)
}
type OSORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*OS, *gorm.DB) error
}

// DefaultStrictUpdateOS clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateOS(ctx context.Context, in *OS, db *gorm.DB) (*OS, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateOS")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &OSORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(OSORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterFingerprints := OSFingerprintORM{}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	filterFingerprints.OSId = new(string)
	*filterFingerprints.OSId = ormObj.Id
	if err = db.Where(filterFingerprints).Delete(OSFingerprintORM{}).Error; err != nil {
		return nil, err
	}
	filterMatches := OSMatchORM{}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	filterMatches.OSId = new(string)
	*filterMatches.OSId = ormObj.Id
	if err = db.Where(filterMatches).Delete(OSMatchORM{}).Error; err != nil {
		return nil, err
	}
	filterPortsUsed := PortUsedORM{}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	filterPortsUsed.OSId = new(string)
	*filterPortsUsed.OSId = ormObj.Id
	if err = db.Where(filterPortsUsed).Delete(PortUsedORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(OSORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(OSORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type OSORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OSORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OSORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchOS executes a basic gorm update call with patch behavior
func DefaultPatchOS(ctx context.Context, in *OS, updateMask *field_mask.FieldMask, db *gorm.DB) (*OS, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj OS
	var err error
	if hook, ok := interface{}(&pbObj).(OSWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadOS(ctx, &OS{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(OSWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskOS(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(OSWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateOS(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(OSWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type OSWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *OS, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type OSWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *OS, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type OSWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *OS, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type OSWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *OS, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetOS executes a bulk gorm update call with patch behavior
func DefaultPatchSetOS(ctx context.Context, objects []*OS, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*OS, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*OS, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchOS(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskOS patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskOS(ctx context.Context, patchee *OS, patcher *OS, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*OS, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"PortsUsed" {
			patchee.PortsUsed = patcher.PortsUsed
			continue
		}
		if f == prefix+"Matches" {
			patchee.Matches = patcher.Matches
			continue
		}
		if f == prefix+"Fingerprints" {
			patchee.Fingerprints = patcher.Fingerprints
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListOS executes a gorm list call
func DefaultListOS(ctx context.Context, db *gorm.DB) ([]*OS, error) {
	in := OS{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(OSORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(OSORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []OSORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(OSORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*OS{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type OSORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OSORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OSORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]OSORM) error
}

// DefaultCreateOSMatch executes a basic gorm create call
func DefaultCreateOSMatch(ctx context.Context, in *OSMatch, db *gorm.DB) (*OSMatch, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(OSMatchORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(OSMatchORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type OSMatchORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OSMatchORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadOSMatch(ctx context.Context, in *OSMatch, db *gorm.DB) (*OSMatch, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(OSMatchORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(OSMatchORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := OSMatchORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(OSMatchORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type OSMatchORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OSMatchORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OSMatchORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteOSMatch(ctx context.Context, in *OSMatch, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(OSMatchORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&OSMatchORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(OSMatchORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type OSMatchORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OSMatchORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteOSMatchSet(ctx context.Context, in []*OSMatch, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&OSMatchORM{})).(OSMatchORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&OSMatchORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&OSMatchORM{})).(OSMatchORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type OSMatchORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*OSMatch, *gorm.DB) (*gorm.DB, error)
}
type OSMatchORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*OSMatch, *gorm.DB) error
}

// DefaultStrictUpdateOSMatch clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateOSMatch(ctx context.Context, in *OSMatch, db *gorm.DB) (*OSMatch, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateOSMatch")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &OSMatchORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(OSMatchORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterClasses := OSClassORM{}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	filterClasses.OSMatchId = new(string)
	*filterClasses.OSMatchId = ormObj.Id
	if err = db.Where(filterClasses).Delete(OSClassORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(OSMatchORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(OSMatchORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type OSMatchORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OSMatchORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OSMatchORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchOSMatch executes a basic gorm update call with patch behavior
func DefaultPatchOSMatch(ctx context.Context, in *OSMatch, updateMask *field_mask.FieldMask, db *gorm.DB) (*OSMatch, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj OSMatch
	var err error
	if hook, ok := interface{}(&pbObj).(OSMatchWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadOSMatch(ctx, &OSMatch{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(OSMatchWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskOSMatch(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(OSMatchWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateOSMatch(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(OSMatchWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type OSMatchWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *OSMatch, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type OSMatchWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *OSMatch, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type OSMatchWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *OSMatch, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type OSMatchWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *OSMatch, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetOSMatch executes a bulk gorm update call with patch behavior
func DefaultPatchSetOSMatch(ctx context.Context, objects []*OSMatch, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*OSMatch, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*OSMatch, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchOSMatch(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskOSMatch patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskOSMatch(ctx context.Context, patchee *OSMatch, patcher *OSMatch, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*OSMatch, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Accuracy" {
			patchee.Accuracy = patcher.Accuracy
			continue
		}
		if f == prefix+"Line" {
			patchee.Line = patcher.Line
			continue
		}
		if f == prefix+"Classes" {
			patchee.Classes = patcher.Classes
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListOSMatch executes a gorm list call
func DefaultListOSMatch(ctx context.Context, db *gorm.DB) ([]*OSMatch, error) {
	in := OSMatch{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(OSMatchORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(OSMatchORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []OSMatchORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(OSMatchORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*OSMatch{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type OSMatchORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OSMatchORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OSMatchORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]OSMatchORM) error
}

// DefaultCreatePortUsed executes a basic gorm create call
func DefaultCreatePortUsed(ctx context.Context, in *PortUsed, db *gorm.DB) (*PortUsed, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PortUsedORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PortUsedORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PortUsedORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PortUsedORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPortUsed(ctx context.Context, in *PortUsed, db *gorm.DB) (*PortUsed, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PortUsedORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PortUsedORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PortUsedORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PortUsedORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PortUsedORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PortUsedORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PortUsedORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePortUsed(ctx context.Context, in *PortUsed, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PortUsedORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PortUsedORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PortUsedORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PortUsedORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PortUsedORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePortUsedSet(ctx context.Context, in []*PortUsed, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PortUsedORM{})).(PortUsedORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PortUsedORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PortUsedORM{})).(PortUsedORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PortUsedORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*PortUsed, *gorm.DB) (*gorm.DB, error)
}
type PortUsedORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*PortUsed, *gorm.DB) error
}

// DefaultStrictUpdatePortUsed clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePortUsed(ctx context.Context, in *PortUsed, db *gorm.DB) (*PortUsed, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePortUsed")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PortUsedORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PortUsedORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PortUsedORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PortUsedORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PortUsedORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PortUsedORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PortUsedORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPortUsed executes a basic gorm update call with patch behavior
func DefaultPatchPortUsed(ctx context.Context, in *PortUsed, updateMask *field_mask.FieldMask, db *gorm.DB) (*PortUsed, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj PortUsed
	var err error
	if hook, ok := interface{}(&pbObj).(PortUsedWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPortUsed(ctx, &PortUsed{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PortUsedWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPortUsed(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PortUsedWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePortUsed(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PortUsedWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PortUsedWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *PortUsed, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PortUsedWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *PortUsed, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PortUsedWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *PortUsed, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PortUsedWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *PortUsed, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPortUsed executes a bulk gorm update call with patch behavior
func DefaultPatchSetPortUsed(ctx context.Context, objects []*PortUsed, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*PortUsed, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*PortUsed, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPortUsed(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPortUsed patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPortUsed(ctx context.Context, patchee *PortUsed, patcher *PortUsed, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*PortUsed, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Number" {
			patchee.Number = patcher.Number
			continue
		}
		if f == prefix+"State" {
			patchee.State = patcher.State
			continue
		}
		if f == prefix+"Protocol" {
			patchee.Protocol = patcher.Protocol
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPortUsed executes a gorm list call
func DefaultListPortUsed(ctx context.Context, db *gorm.DB) ([]*PortUsed, error) {
	in := PortUsed{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PortUsedORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PortUsedORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PortUsedORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PortUsedORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*PortUsed{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PortUsedORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PortUsedORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PortUsedORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PortUsedORM) error
}

// DefaultCreateOSFingerprint executes a basic gorm create call
func DefaultCreateOSFingerprint(ctx context.Context, in *OSFingerprint, db *gorm.DB) (*OSFingerprint, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(OSFingerprintORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(OSFingerprintORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type OSFingerprintORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OSFingerprintORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadOSFingerprint(ctx context.Context, in *OSFingerprint, db *gorm.DB) (*OSFingerprint, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(OSFingerprintORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(OSFingerprintORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := OSFingerprintORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(OSFingerprintORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type OSFingerprintORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OSFingerprintORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OSFingerprintORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteOSFingerprint(ctx context.Context, in *OSFingerprint, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(OSFingerprintORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&OSFingerprintORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(OSFingerprintORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type OSFingerprintORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OSFingerprintORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteOSFingerprintSet(ctx context.Context, in []*OSFingerprint, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&OSFingerprintORM{})).(OSFingerprintORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&OSFingerprintORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&OSFingerprintORM{})).(OSFingerprintORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type OSFingerprintORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*OSFingerprint, *gorm.DB) (*gorm.DB, error)
}
type OSFingerprintORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*OSFingerprint, *gorm.DB) error
}

// DefaultStrictUpdateOSFingerprint clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateOSFingerprint(ctx context.Context, in *OSFingerprint, db *gorm.DB) (*OSFingerprint, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateOSFingerprint")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &OSFingerprintORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(OSFingerprintORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(OSFingerprintORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(OSFingerprintORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type OSFingerprintORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OSFingerprintORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OSFingerprintORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchOSFingerprint executes a basic gorm update call with patch behavior
func DefaultPatchOSFingerprint(ctx context.Context, in *OSFingerprint, updateMask *field_mask.FieldMask, db *gorm.DB) (*OSFingerprint, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj OSFingerprint
	var err error
	if hook, ok := interface{}(&pbObj).(OSFingerprintWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadOSFingerprint(ctx, &OSFingerprint{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(OSFingerprintWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskOSFingerprint(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(OSFingerprintWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateOSFingerprint(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(OSFingerprintWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type OSFingerprintWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *OSFingerprint, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type OSFingerprintWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *OSFingerprint, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type OSFingerprintWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *OSFingerprint, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type OSFingerprintWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *OSFingerprint, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetOSFingerprint executes a bulk gorm update call with patch behavior
func DefaultPatchSetOSFingerprint(ctx context.Context, objects []*OSFingerprint, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*OSFingerprint, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*OSFingerprint, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchOSFingerprint(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskOSFingerprint patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskOSFingerprint(ctx context.Context, patchee *OSFingerprint, patcher *OSFingerprint, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*OSFingerprint, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Fingerprint" {
			patchee.Fingerprint = patcher.Fingerprint
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListOSFingerprint executes a gorm list call
func DefaultListOSFingerprint(ctx context.Context, db *gorm.DB) ([]*OSFingerprint, error) {
	in := OSFingerprint{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(OSFingerprintORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(OSFingerprintORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []OSFingerprintORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(OSFingerprintORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*OSFingerprint{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type OSFingerprintORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OSFingerprintORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OSFingerprintORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]OSFingerprintORM) error
}

// DefaultCreateOSClass executes a basic gorm create call
func DefaultCreateOSClass(ctx context.Context, in *OSClass, db *gorm.DB) (*OSClass, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(OSClassORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(OSClassORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type OSClassORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OSClassORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadOSClass(ctx context.Context, in *OSClass, db *gorm.DB) (*OSClass, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(OSClassORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(OSClassORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := OSClassORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(OSClassORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type OSClassORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OSClassORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OSClassORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteOSClass(ctx context.Context, in *OSClass, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(OSClassORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&OSClassORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(OSClassORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type OSClassORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OSClassORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteOSClassSet(ctx context.Context, in []*OSClass, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&OSClassORM{})).(OSClassORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&OSClassORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&OSClassORM{})).(OSClassORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type OSClassORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*OSClass, *gorm.DB) (*gorm.DB, error)
}
type OSClassORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*OSClass, *gorm.DB) error
}

// DefaultStrictUpdateOSClass clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateOSClass(ctx context.Context, in *OSClass, db *gorm.DB) (*OSClass, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateOSClass")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &OSClassORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(OSClassORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(OSClassORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(OSClassORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type OSClassORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OSClassORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OSClassORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchOSClass executes a basic gorm update call with patch behavior
func DefaultPatchOSClass(ctx context.Context, in *OSClass, updateMask *field_mask.FieldMask, db *gorm.DB) (*OSClass, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj OSClass
	var err error
	if hook, ok := interface{}(&pbObj).(OSClassWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadOSClass(ctx, &OSClass{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(OSClassWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskOSClass(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(OSClassWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateOSClass(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(OSClassWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type OSClassWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *OSClass, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type OSClassWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *OSClass, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type OSClassWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *OSClass, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type OSClassWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *OSClass, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetOSClass executes a bulk gorm update call with patch behavior
func DefaultPatchSetOSClass(ctx context.Context, objects []*OSClass, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*OSClass, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*OSClass, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchOSClass(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskOSClass patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskOSClass(ctx context.Context, patchee *OSClass, patcher *OSClass, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*OSClass, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Vendor" {
			patchee.Vendor = patcher.Vendor
			continue
		}
		if f == prefix+"OSGeneration" {
			patchee.OSGeneration = patcher.OSGeneration
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"Accuracy" {
			patchee.Accuracy = patcher.Accuracy
			continue
		}
		if f == prefix+"Family" {
			patchee.Family = patcher.Family
			continue
		}
		if f == prefix+"CPEs" {
			patchee.CPEs = patcher.CPEs
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListOSClass executes a gorm list call
func DefaultListOSClass(ctx context.Context, db *gorm.DB) ([]*OSClass, error) {
	in := OSClass{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(OSClassORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(OSClassORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []OSClassORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(OSClassORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*OSClass{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type OSClassORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OSClassORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OSClassORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]OSClassORM) error
}
